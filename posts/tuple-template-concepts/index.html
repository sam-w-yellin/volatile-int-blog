<!doctype html><html lang=en dir=auto data-theme=auto><link rel=stylesheet href=https://www.volatileint.dev/css/custom.css><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Applying Template Concepts to Tuples in C++ | Volatile Int</title><meta name=keywords content="crunch,C++,template,tuple,concept,tuple-like"><meta name=description content="Learn how to apply and constrain C++20 template concepts to tuple elements with practical examples and idiomatic patterns."><meta name=author content><link rel=canonical href=https://www.volatileint.dev/posts/tuple-template-concepts/><link crossorigin=anonymous href=https://www.volatileint.dev/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://www.volatileint.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.volatileint.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.volatileint.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://www.volatileint.dev/apple-touch-icon.png><link rel=mask-icon href=https://www.volatileint.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.volatileint.dev/posts/tuple-template-concepts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-N81PSXWFLZ"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-N81PSXWFLZ")}</script><meta property="og:url" content="https://www.volatileint.dev/posts/tuple-template-concepts/"><meta property="og:site_name" content="Volatile Int"><meta property="og:title" content="Applying Template Concepts to Tuples in C++"><meta property="og:description" content="Learn how to apply and constrain C++20 template concepts to tuple elements with practical examples and idiomatic patterns."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-23T00:00:00-08:00"><meta property="article:modified_time" content="2025-12-23T00:00:00-08:00"><meta property="article:tag" content="Crunch"><meta property="article:tag" content="C++"><meta property="article:tag" content="Template"><meta property="article:tag" content="Tuple"><meta property="article:tag" content="Concept"><meta property="article:tag" content="Tuple-Like"><meta name=twitter:card content="summary"><meta name=twitter:title content="Applying Template Concepts to Tuples in C++"><meta name=twitter:description content="Learn how to apply and constrain C++20 template concepts to tuple elements with practical examples and idiomatic patterns."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.volatileint.dev/posts/"},{"@type":"ListItem","position":2,"name":"Applying Template Concepts to Tuples in C++","item":"https://www.volatileint.dev/posts/tuple-template-concepts/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Applying Template Concepts to Tuples in C++","name":"Applying Template Concepts to Tuples in C\u002b\u002b","description":"Learn how to apply and constrain C++20 template concepts to tuple elements with practical examples and idiomatic patterns.","keywords":["crunch","C++","template","tuple","concept","tuple-like"],"articleBody":"Tuples and Templates In C++, tuples are a collection of values of heterogenous types. You can access different elements at compile time via the get method, while the std::tuple_size and std::tuple_element APIs provide metadata about the collection’s structure. Classes that satisfy this “Tuple Protocol” in the STL - and can therefore utilize the techniques in this article - include std::tuple, std::pair, std::array, and some types in the std::ranges library.\nWhen we use templates, the C++ Core Guidelines tell us to specify concepts for all parameters. This article demonstrates a few methods for applying concepts to tuples and their individual elements. While developing Crunch, I had quite a few use cases for applying template concepts to tuples and found some good - and not so good - ways to do it. I did not find any clear explanations of the syntax proposed for those solutions, or how you could arrive at them yourself. I hope that by the end of this article, you feel comfortable writing template concepts targeting std::tuple parameters in your own projects!\nFor a quick tl;dr - this is what we are going to work up to:\nWhen you need to inspect types or constexpr values of each element\ntemplate \u003ctypename Tuple\u003e concept ElementsAreIntegral = []\u003cstd::size_t... Is\u003e(std::index_sequence\u003cIs...\u003e) { return (SomeConcept\u003c std::remove_cvref_t\u003cstd::tuple_element_t\u003cIs, Tuple\u003e\u003e \u003e \u0026\u0026 ...); }(std::make_index_sequence\u003cstd::tuple_size_v\u003cTuple\u003e\u003e{}); When you don’t need to inspect each element\ntemplate\u003ctypename Tuple\u003e concept ElementsSatisfyConcept = requires { std::apply( []\u003ctypename... Ts\u003e(Ts\u0026\u0026...) requires (std::remove_cvref_t\u003cSomeConcept\u003cTs\u003e\u003e \u0026\u0026 ...) {}, std::declval\u003cTuple\u003e() ); }; The rest of this article will provide the context on what those concepts are actually doing, how they work, and motivate how you could arrive there yourself from the ground up.\nAsserting a Template Parameter is a Tuple-Like Object First, let’s address the most basic conceptual constraint - that the Tuple template parameter is actually a tuple-like type. The C++ standard defines tuple-like types as a strictly enumerated set of types rather than as an object that satisfys the tuple-like inteface. The definition is:\nA type T models and satisfies the concept tuple-like if std::remove_cvref_t is a specialization of:\nstd::array, std::complex (since C++26) std::pair, std::tuple std::ranges::subrange. As of this writing, gcc is the only compiler I have found which defines a concept in the STL for checking if a class is derived from one of these tuple-like classes, and its hidden as std::__is_tuple_like_v. This Godbolt demonstrates its use on GCC trunk for x86_64 targets. GCC’s implementation can be found here. Note how the implementation doesn’t check for adherence to the tuple protocol APIs, it just hard codes in true if the class is one of the enumerated types in the standard.\nOur Motivaging Example More interseting than checking if a template paramter is a tuple-like object is applying concepts to the elements inside a tuple.\nTake a template class which takes some tuple:\ntemplate \u003ctypename Tuple\u003e class Foo { Tuple my_tuple; }; Let’s say that we want each element in Tuple to satisfy std::integral or compilation should fail. Something ergonomically similar to this:\ntemplate \u003ctypename Tuple\u003e requires ElementsAreIntegral\u003cTuple\u003e class Foo { Tuple my_tuple; }; The intuitive high-level approach to accomplishing this is:\nSomehow “unpack” the tuple into each of its elements Apply the std::integral concept to each Fail the concept if any do not satisfy std::integral The Manual Approach In our first approach, we’re going to tackle each of the above steps independently. I call this “manual” because it uses fewer language features and more boilerplate as compared to the next solutions we will look at.\nFirst off, we know that we need a concept called ElementsAreIntegral.\ntemplate\u003ctypename Tuple\u003e concept ElementsAreIntegral = // ...something... Our goal is to have ElementsAreIntegral evaluate to true when the elements meet std::integral and false when they do not.\nUltimately we are going to need to unpack this tuple and check the elements. We need something that expands out all the tuple elements, applies the target concept, and returns false if any are not satisfied:\n// Note: this cannot be our final concept — it requires an index pack template \u003ctypename Tuple, std::size_t... Is\u003e concept ElementsAreIntegralWithSequenceIdx = (std::integral\u003cstd::tuple_element_t\u003cIs, Tuple\u003e\u003e \u0026\u0026 ...); Its possible the the tuple was declared with reference or CV-qualified parameters, and your concept probably takes an unqualified, non-reference value. So you’ll probably want to actually make sure we strip the reference \u0026 CV qualification from the tuple elements:\n// Note: this cannot be our final concept — it requires an index pack template \u003ctypename Tuple, std::size_t... Is\u003e concept ElementsAreIntegralWithSequenceIdx = (std::integral\u003cstd::remove_cvref_t\u003c std::tuple_element_t\u003cIs, Tuple\u003e\u003e \u003e \u0026\u0026 ...); This looks really close to what we want. We are assuming we somehow create a template parameter pack Is which contains the index of each tuple element. Then, when unpacking, we use the index to get the tuple element then logically AND the result of each individual tuple element’s concept check.\nHow do we get Is? The STL contains a few utility functions that combine to do exactly what we need. First, we can use std::tuple_size_v to extract out the size of a the tuple, then we can pass the result as a template parameter to std::make_index_sequence to get the list of indices.\nstd::make_index_sequence\u003cstd::tuple_size_v\u003cTuple\u003e\u003e; Now we have most of the logic in place. But we need to bridge the gap between the desired concept - which takes only the Tuple parameter - and this concept which takes in the tuple and a sequence of indices. Intuitively, it probably seems like this is the right sort of approach:\ntemplate \u003ctypename Tuple, std::size_t... Is\u003e concept ElementsAreIntegralImpl = (std::integral\u003cstd::remove_cvref_t\u003c std::tuple_element_t\u003cIs, Tuple\u003e\u003e \u003e \u0026\u0026 ...); template\u003ctypename Tuple\u003e concept ElementsAreIntegral = ElementsAreIntegralImpl\u003cTuple, std::make_index_sequence\u003cstd::tuple_size_v\u003cTuple\u003e\u003e\u003e; But there’s a problem here. Is is a parameter pack. std::make_index_sequence","wordCount":"2389","inLanguage":"en","datePublished":"2025-12-23T00:00:00-08:00","dateModified":"2025-12-23T00:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.volatileint.dev/posts/tuple-template-concepts/"},"publisher":{"@type":"Organization","name":"Volatile Int","logo":{"@type":"ImageObject","url":"https://www.volatileint.dev/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://www.volatileint.dev/ accesskey=h title="  (Alt + H)"><img src=https://www.volatileint.dev/images/top-logo-light.svg alt aria-label=logo height=32></a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.volatileint.dev/about/ title=About><span>About</span></a></li><li><a href=https://www.volatileint.dev/newsletter/ title=Newsletter><span>Newsletter</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Applying Template Concepts to Tuples in C++</h1><div class=post-description>Learn how to apply and constrain C++20 template concepts to tuple elements with practical examples and idiomatic patterns.</div><div class=post-meta><span title='2025-12-23 00:00:00 -0800 -0800'>December 23, 2025</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#tuples-and-templates aria-label="Tuples and Templates">Tuples and Templates</a><ul><li><a href=#asserting-a-template-parameter-is-a-tuple-like-object aria-label="Asserting a Template Parameter is a Tuple-Like Object">Asserting a Template Parameter is a Tuple-Like Object</a></li></ul></li><li><a href=#our-motivaging-example aria-label="Our Motivaging Example">Our Motivaging Example</a><ul><li><a href=#the-manual-approach aria-label="The Manual Approach">The Manual Approach</a></li><li><a href=#variadic-lambda-approach aria-label="Variadic Lambda Approach">Variadic Lambda Approach</a></li><li><a href=#stdapply-approach aria-label="std::apply Approach">std::apply Approach</a></li></ul></li><li><a href=#real-world-example aria-label="Real-World Example">Real-World Example</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><h1 id=tuples-and-templates>Tuples and Templates<a hidden class=anchor aria-hidden=true href=#tuples-and-templates>#</a></h1><p>In C++, tuples are a collection of values of heterogenous types. You can access different elements at compile time via the <code>get</code> method, while the <code>std::tuple_size</code> and <code>std::tuple_element</code> APIs provide metadata about the collection&rsquo;s structure. Classes that satisfy this &ldquo;Tuple Protocol&rdquo; in the <code>STL</code> - and can therefore utilize the techniques in this article - include <code>std::tuple</code>, <code>std::pair</code>, <code>std::array</code>, and some types in the <code>std::ranges</code> library.</p><p>When we use templates, the C++ Core Guidelines <a href=https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#rt-concepts>tell us to specify concepts for all parameters</a>. This article demonstrates a few methods for applying concepts to tuples and their individual elements. While <a href=https://www.volatileint.dev/posts/crunch-intro/>developing Crunch</a>, I had quite a few use cases for applying template concepts to tuples and found some good - and not so good - ways to do it. I did not find any clear explanations of the syntax proposed for those solutions, or how you could arrive at them yourself. I hope that by the end of this article, you feel comfortable writing template concepts targeting <code>std::tuple</code> parameters in your own projects!</p><p>For a quick tl;dr - this is what we are going to work up to:</p><p><strong>When you need to inspect types or constexpr values of each element</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Tuple<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>concept</span> ElementsAreIntegral <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    []<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>size_t... Is<span style=color:#f92672>&gt;</span>(std<span style=color:#f92672>::</span>index_sequence<span style=color:#f92672>&lt;</span>Is...<span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (SomeConcept<span style=color:#f92672>&lt;</span>
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>remove_cvref_t<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>tuple_element_t<span style=color:#f92672>&lt;</span>Is, Tuple<span style=color:#f92672>&gt;&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;&amp;</span> ...);
</span></span><span style=display:flex><span>    }(std<span style=color:#f92672>::</span>make_index_sequence<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>tuple_size_v<span style=color:#f92672>&lt;</span>Tuple<span style=color:#f92672>&gt;&gt;</span>{});
</span></span></code></pre></div><p><strong>When you don&rsquo;t need to inspect each element</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Tuple<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>concept</span> ElementsSatisfyConcept <span style=color:#f92672>=</span> <span style=color:#66d9ef>requires</span> {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>apply(
</span></span><span style=display:flex><span>        []<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span>... Ts<span style=color:#f92672>&gt;</span>(Ts<span style=color:#f92672>&amp;&amp;</span>...)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>requires</span> (std<span style=color:#f92672>::</span>remove_cvref_t<span style=color:#f92672>&lt;</span>SomeConcept<span style=color:#f92672>&lt;</span>Ts<span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;&amp;</span> ...) {},
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>declval<span style=color:#f92672>&lt;</span>Tuple<span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>The rest of this article will provide the context on what those concepts are actually doing, how they work, and motivate how you could arrive there yourself from the ground up.</p><h2 id=asserting-a-template-parameter-is-a-tuple-like-object>Asserting a Template Parameter is a Tuple-Like Object<a hidden class=anchor aria-hidden=true href=#asserting-a-template-parameter-is-a-tuple-like-object>#</a></h2><p>First, let&rsquo;s address the most basic conceptual constraint - that the <code>Tuple</code> template parameter is actually a <code>tuple-like</code> type. The C++ standard defines <code>tuple-like</code> types as a strictly enumerated set of types rather than as an object that satisfys the tuple-like inteface. The definition is:</p><blockquote><p>A type T models and satisfies the concept tuple-like if std::remove_cvref_t is a specialization of:</p><ul><li>std::array,</li><li>std::complex (since C++26)</li><li>std::pair,</li><li>std::tuple</li><li>std::ranges::subrange.</li></ul></blockquote><p>As of this writing, <code>gcc</code> is the only compiler I have found which defines a concept in the <code>STL</code> for checking if a class is derived from one of these tuple-like classes, and its hidden as <code>std::__is_tuple_like_v</code>. <a href=https://godbolt.org/z/1rE3q6z6j>This Godbolt</a> demonstrates its use on GCC trunk for x86_64 targets. GCC&rsquo;s implementation can be found <a href=https://www.mail-archive.com/gcc-patches@gcc.gnu.org/msg332404.html>here</a>. Note how the implementation doesn&rsquo;t check for adherence to the tuple protocol APIs, it just hard codes in <code>true</code> if the class is one of the enumerated types in the standard.</p><h1 id=our-motivaging-example>Our Motivaging Example<a hidden class=anchor aria-hidden=true href=#our-motivaging-example>#</a></h1><p>More interseting than checking if a template paramter is a <code>tuple-like</code> object is applying concepts to the elements inside a tuple.</p><p>Take a template class which takes some tuple:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Tuple<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Foo</span> {
</span></span><span style=display:flex><span>    Tuple my_tuple;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Let&rsquo;s say that we want each element in <code>Tuple</code> to satisfy <code>std::integral</code> or compilation should fail. Something ergonomically similar to this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Tuple<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>requires</span> ElementsAreIntegral<span style=color:#f92672>&lt;</span>Tuple<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Foo</span> {
</span></span><span style=display:flex><span>    Tuple my_tuple;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>The intuitive high-level approach to accomplishing this is:</p><ol><li>Somehow &ldquo;unpack&rdquo; the tuple into each of its elements</li><li>Apply the <code>std::integral</code> concept to each</li><li>Fail the concept if any do not satisfy <code>std::integral</code></li></ol><h2 id=the-manual-approach>The Manual Approach<a hidden class=anchor aria-hidden=true href=#the-manual-approach>#</a></h2><p>In our first approach, we&rsquo;re going to tackle each of the above steps independently. I call this &ldquo;manual&rdquo; because it uses fewer language features and more boilerplate as compared to the next solutions we will look at.</p><p>First off, we know that we need a concept called <code>ElementsAreIntegral</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Tuple<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>concept</span> ElementsAreIntegral <span style=color:#f92672>=</span> <span style=color:#75715e>// ...something...
</span></span></span></code></pre></div><p>Our goal is to have <code>ElementsAreIntegral</code> evaluate to <code>true</code> when the elements meet <code>std::integral</code> and <code>false</code> when they do not.</p><p>Ultimately we are going to need to unpack this tuple and check the elements. We need something that expands out all the tuple elements, applies the target concept, and returns false if any are not satisfied:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>// Note: this cannot be our final concept — it requires an index pack
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Tuple, std<span style=color:#f92672>::</span>size_t... Is<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>concept</span> ElementsAreIntegralWithSequenceIdx <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    (std<span style=color:#f92672>::</span>integral<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>tuple_element_t<span style=color:#f92672>&lt;</span>Is, Tuple<span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;&amp;</span> ...);
</span></span></code></pre></div><p>Its possible the the tuple was declared with reference or CV-qualified parameters, and your concept probably takes an unqualified, non-reference value. So you&rsquo;ll probably want to actually make sure we strip the reference & CV qualification from the tuple elements:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>// Note: this cannot be our final concept — it requires an index pack
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Tuple, std<span style=color:#f92672>::</span>size_t... Is<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>concept</span> ElementsAreIntegralWithSequenceIdx <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    (std<span style=color:#f92672>::</span>integral<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>remove_cvref_t<span style=color:#f92672>&lt;</span>
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>tuple_element_t<span style=color:#f92672>&lt;</span>Is, Tuple<span style=color:#f92672>&gt;&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;&amp;</span> ...);
</span></span></code></pre></div><p>This looks really close to what we want. We are assuming we somehow create a template parameter pack <code>Is</code> which contains the index of each tuple element. Then, when unpacking, we use the index to get the tuple element then logically <code>AND</code> the result of each individual tuple element&rsquo;s concept check.</p><p>How do we get <code>Is</code>? The <code>STL</code> contains a few utility functions that combine to do exactly what we need. First, we can use <code>std::tuple_size_v</code> to extract out the size of a the tuple, then we can pass the result as a template parameter to <code>std::make_index_sequence</code> to get the list of indices.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span>std<span style=color:#f92672>::</span>make_index_sequence<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>tuple_size_v<span style=color:#f92672>&lt;</span>Tuple<span style=color:#f92672>&gt;&gt;</span>;
</span></span></code></pre></div><p>Now we have most of the logic in place. But we need to bridge the gap between the desired concept - which takes only the <code>Tuple</code> parameter - and this concept which takes in the tuple and a sequence of indices. Intuitively, it probably seems like this is the right sort of approach:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Tuple, std<span style=color:#f92672>::</span>size_t... Is<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>concept</span> ElementsAreIntegralImpl <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>   (std<span style=color:#f92672>::</span>integral<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>remove_cvref_t<span style=color:#f92672>&lt;</span>
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>tuple_element_t<span style=color:#f92672>&lt;</span>Is, Tuple<span style=color:#f92672>&gt;&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;&amp;</span> ...);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Tuple<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>concept</span> ElementsAreIntegral <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    ElementsAreIntegralImpl<span style=color:#f92672>&lt;</span>Tuple, std<span style=color:#f92672>::</span>make_index_sequence<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>tuple_size_v<span style=color:#f92672>&lt;</span>Tuple<span style=color:#f92672>&gt;&gt;&gt;</span>;
</span></span></code></pre></div><p>But there&rsquo;s a problem here. <code>Is</code> is a <em>parameter pack</em>. <code>std::make_index_sequence&lt;std::tuple_size_v&lt;Tuple>></code> returns a <em>type</em> which has the parameter pack we want <em>inside</em> - something like <code>std::index_sequence&lt;0, 1, 2, ..., N></code>. In order to get at that set of indices inside the sequence, we need to bind to that sequence. We can do this with a <em>partial template specialization</em>. We need a template that is specialized on the <code>std::index_sequence</code> parameter pack. Something like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>size_t...Is<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>sequence_extractor</span><span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>index_sequence<span style=color:#f92672>&lt;</span>Is...<span style=color:#f92672>&gt;&gt;</span> {};
</span></span></code></pre></div><p>Now we have a mechanism to bind the results of <code>std::make_index_sequence</code> to a template parameter pack. We need a struct which utilizes that mechanism to pull out the parameter pack, and which exposes a boolean value to the top-level <code>ElementsAreIntegral</code> concept representing if each element is <code>std::integral</code>. We can is utilize a struct that extracts out the <code>std::index_sequence</code> as a parameter pack, <em>and</em> have that struct extend <code>std::bool_constant</code>, where the <code>value</code> of that boolean constant is predicated on the result of <code>ElementsAreIntegralImpl</code>. That&rsquo;s quite a mouthful, let&rsquo;s write it out step by step.</p><p>First, we define our top-level concept to be predicated on the <code>::value</code> static member of a struct we will define. We&rsquo;ll call that struct <code>SequenceHelper</code>. It is templated on the <code>Tuple</code> parameter to the top-level concept and the result of <code>std::make_index_sequence</code> on that parameter. Both parameters are required because we need to forward them onto the <code>ElementsAreIntegralImpl</code> concept.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Tuple<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>concept</span> ElementsAreIntegral <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    SequenceHelper<span style=color:#f92672>&lt;</span>
</span></span><span style=display:flex><span>        Tuple, 
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>make_index_sequence<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>tuple_size_v<span style=color:#f92672>&lt;</span>Tuple<span style=color:#f92672>&gt;&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&gt;::</span>value
</span></span></code></pre></div><p>Now, we need to actually write our <code>SequenceHelper</code>. Remember, this thing&rsquo;s job is to bind a template parameter to the <code>std::index_sequence</code>&rsquo;s parameter pack, and forward it to the <code>ElementsAreIntegralImpl</code> which actually checks if each element fulfills <code>std::integral</code>. We derive this struct from <code>std::bool_constant</code> so that it has a <code>::value</code> static data member. The value of the constant is set to the result of <code>ElementsAreIntegralImpl</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>// base
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Tuple, <span style=color:#66d9ef>typename</span> IndexSeq<span style=color:#f92672>&gt;</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SequenceHelper</span> <span style=color:#f92672>:</span> std<span style=color:#f92672>::</span>false_type {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// partial specialization
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Tuple, std<span style=color:#f92672>::</span>size_t...Is<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SequenceHelper</span><span style=color:#f92672>&lt;</span>Tuple, std<span style=color:#f92672>::</span>index_sequence<span style=color:#f92672>&lt;</span>Is...<span style=color:#f92672>&gt;&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>:</span> std<span style=color:#f92672>::</span>bool_constant<span style=color:#f92672>&lt;</span>ElementsAreIntegralImpl<span style=color:#f92672>&lt;</span>Tuple, Is...<span style=color:#f92672>&gt;&gt;</span> {};
</span></span></code></pre></div><p>See how we were able to <em>extract</em> the parameter pack from the <code>std::index_sequence</code> and pass it to <code>ElementsAreIntegralImpl</code>? We now can pull it all together for our final, working implementation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Tuple, std<span style=color:#f92672>::</span>size_t... Is<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>concept</span> ElementsAreIntegralImpl <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    (std<span style=color:#f92672>::</span>integral<span style=color:#f92672>&lt;</span>
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>remove_cvref_t<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>tuple_element_t<span style=color:#f92672>&lt;</span>Is, Tuple<span style=color:#f92672>&gt;&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;&amp;</span> ...);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// base
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Tuple, <span style=color:#66d9ef>typename</span> IndexSeq<span style=color:#f92672>&gt;</span> 
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SequenceHelper</span> <span style=color:#f92672>:</span> std<span style=color:#f92672>::</span>false_type {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// partial specialization
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Tuple, std<span style=color:#f92672>::</span>size_t...Is<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SequenceHelper</span><span style=color:#f92672>&lt;</span>Tuple, std<span style=color:#f92672>::</span>index_sequence<span style=color:#f92672>&lt;</span>Is...<span style=color:#f92672>&gt;&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>:</span> std<span style=color:#f92672>::</span>bool_constant<span style=color:#f92672>&lt;</span>ElementsAreIntegralImpl<span style=color:#f92672>&lt;</span>Tuple, Is...<span style=color:#f92672>&gt;&gt;</span> {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Tuple<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>concept</span> ElementsAreIntegral <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    SequenceHelper<span style=color:#f92672>&lt;</span>
</span></span><span style=display:flex><span>        Tuple, 
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>make_index_sequence<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>tuple_size_v<span style=color:#f92672>&lt;</span>Tuple<span style=color:#f92672>&gt;&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&gt;::</span>value;
</span></span></code></pre></div><p>This example can be seen in action at this <a href=https://godbolt.org/z/6fW61fqbs>Godbolt link</a>.</p><h2 id=variadic-lambda-approach>Variadic Lambda Approach<a hidden class=anchor aria-hidden=true href=#variadic-lambda-approach>#</a></h2><p>Along with template concepts, C++20 introduced <em>generic template lambda</em> functions. These interact in super interesting ways with template metaprogramming, and are very useful in simplifying the code in the &ldquo;manual&rdquo; approach. Here&rsquo;s the basic idea: instead of the &ldquo;helper&rdquo; structs for extracting the parameter pack from inside the <code>std::index_sequence</code> and containing the result of the concept applied to each parameter, a template lambda can accept the sequence as a parameter. Then we can collapse both the &ldquo;implementation&rdquo; concept and the pack extraction into the top-level concept.</p><p>So, we want a concept that calls a templated lambda function which:</p><ol><li>Takes a <code>std::index_sequence</code> as an input parameter</li><li>Is templated on that sequence&rsquo;s parameter pack</li><li>Calls <code>std::integral</code> on each element in the pack</li></ol><p>If the result evaluates to <code>false</code> - meaning any of the elements is not integral, the concept evaluates to false.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Tuple<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>concept</span> ElementsAreIntegral <span style=color:#f92672>=</span> [] <span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>size_t... Is<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    (std<span style=color:#f92672>::</span>index_sequence<span style=color:#f92672>&lt;</span>Is...<span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (std<span style=color:#f92672>::</span>integral<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>remove_cvref_t<span style=color:#f92672>&lt;</span>
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>tuple_element_t<span style=color:#f92672>&lt;</span>Is, Tuple<span style=color:#f92672>&gt;&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;&amp;</span> ...);
</span></span><span style=display:flex><span>    }(std<span style=color:#f92672>::</span>make_index_sequence<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>tuple_size_v<span style=color:#f92672>&lt;</span>Tuple<span style=color:#f92672>&gt;&gt;</span>{});
</span></span></code></pre></div><p>And that&rsquo;s it. All the sequence-extraction is now handled by our templated lambda, so all the proxy types go away. Feel free to play around with the <a href=https://godbolt.org/z/YTzjsxM81>Godbolt example</a>.</p><h2 id=stdapply-approach>std::apply Approach<a hidden class=anchor aria-hidden=true href=#stdapply-approach>#</a></h2><p>You may have realized something about these previous examples - we don&rsquo;t <em>really</em> care what the type or value of any of the tuple elements is. All we really care about is if the element fulfills some concept. So, do we really need to actually create a <code>std::index_sequence</code> that can access each element individually? If you don&rsquo;t need to actually work with the type of each element, we can get even simpler than our previous example. When we don&rsquo;t really care about the elements we can take advantage of <code>std::apply</code> and variadic template lambdas together.</p><p>The intuition here is to utilize the same strategy of binding the tuple elements as a parameter pack to a lambda. Our goal is to create a lambda which is only well-formed if every element meets our desired concept, and then call it on the tuple inside a <code>requires</code> statement. This will fail if any element does not pass - without ever extracting an element explicitly. We&rsquo;ll start with a variadic, templated lambda. Remember - the code in a <code>concept</code>&rsquo;s <code>requires</code> statement is not actually evaluated. All that matters is it is <em>well formed</em>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span>[]<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span>... Ts<span style=color:#f92672>&gt;</span>(Ts<span style=color:#f92672>&amp;&amp;</span>...) {}
</span></span></code></pre></div><p>We are going to bind the tuple elements as the parameter pack. We want this lambda&rsquo;s template to require each element fulfills <code>std::integral</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span>[]<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span>... Ts<span style=color:#f92672>&gt;</span>(Ts<span style=color:#f92672>&amp;&amp;</span>...) <span style=color:#66d9ef>requires</span>
</span></span><span style=display:flex><span>    (std<span style=color:#f92672>::</span>integral<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>remove_cvref_t<span style=color:#f92672>&lt;</span>Ts<span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;&amp;</span> ...) {}
</span></span></code></pre></div><p>We now want to unpack each tuple element into a parameter pack, and call this lambda on those elements. Luckily, this is <em>exactly</em> what <code>std::apply</code> does.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span>std<span style=color:#f92672>::</span>apply(
</span></span><span style=display:flex><span>  []<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span>... Ts<span style=color:#f92672>&gt;</span>(Ts<span style=color:#f92672>&amp;&amp;</span>...) <span style=color:#66d9ef>requires</span>
</span></span><span style=display:flex><span>    (std<span style=color:#f92672>::</span>integral<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>remove_cvref_t<span style=color:#f92672>&lt;</span>Ts<span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;&amp;</span> ...) {},
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...something...
</span></span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>The &ldquo;something&rdquo; we want is an instance of the tuple. Bringing it together as a concept we get:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Tuple<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>concept</span> ElementsAreIntegral <span style=color:#f92672>=</span> <span style=color:#66d9ef>requires</span> {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>apply(
</span></span><span style=display:flex><span>        []<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span>... Ts<span style=color:#f92672>&gt;</span>(Ts<span style=color:#f92672>&amp;&amp;</span>...) <span style=color:#66d9ef>requires</span>
</span></span><span style=display:flex><span>            (std<span style=color:#f92672>::</span>integral<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>remove_cvref_t<span style=color:#f92672>&lt;</span>Ts<span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;&amp;</span> ...) {},
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>declval<span style=color:#f92672>&lt;</span>Tuple<span style=color:#f92672>&gt;</span>()
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Note: The <code>std::declval</code> call is used to instantiate a concrete Tuple parameter in a concept&rsquo;s <code>requires</code> clause.</p><p>This concept&rsquo;s <code>requires</code> clause is only well formed if the constrained lambda is a viable overload, which is only the case if each element in the parameter pack satisfies <code>std::integral</code>.</p><p>Here is the <a href=https://godbolt.org/z/E1j9e4PE4>Godbolt as proof</a>. It&rsquo;s worth calling out that the error message through this approach is significantly more cryptic than in the others. We do eventually see the message about the failed concept, but it is preceded by lots of failures around <code>std::apply</code> as opposed to the extremely clear errors from the prior examples.</p><h1 id=real-world-example>Real-World Example<a hidden class=anchor aria-hidden=true href=#real-world-example>#</a></h1><p><code>Crunch</code>&rsquo;s <code>CRUNCH_MESSAGE_FIELDS</code> macro creates a <code>constexpr</code> <code>get_fields</code> function for easy iteration over all the fields in a message. It returns a tuple where each element is <code>crunch::field::Field</code>. I needed to apply two different template concepts to the set of elements in the tuple:</p><ol><li>Each field needed to satisfy the <code>ValidField</code> concept, which essentially ensures that the field is one of the Crunch field types (Scalar, Array, Map, Submessage).</li><li>The field&rsquo;s <code>FieldId</code> needs to be unique among all the fields in the message.</li></ol><p>To accomplish this, I utilized both the lambda-based approaches. The <a href=https://github.com/sam-w-yellin/crunch/blob/24f25f48600b88ea0039ae87b74a35fcda471b1f/include/crunch/messages/crunch_messages.hpp#L66>first case</a> was a great candidate for the <code>std::apply</code> approach - the specifics of each type was not important, just that it satisfies a particular concept.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Tuple<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>concept</span> tuple_members_are_valid_fields <span style=color:#f92672>=</span> <span style=color:#66d9ef>requires</span> {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>apply([]<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span>... Ts<span style=color:#f92672>&gt;</span>(Ts<span style=color:#f92672>&amp;&amp;</span>...)
</span></span><span style=display:flex><span>                   <span style=color:#66d9ef>requires</span>(ValidField<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>remove_cvref_t<span style=color:#f92672>&lt;</span>Ts<span style=color:#f92672>&gt;&gt;</span> <span style=color:#f92672>&amp;&amp;</span> ...)
</span></span><span style=display:flex><span>               {},
</span></span><span style=display:flex><span>               std<span style=color:#f92672>::</span>declval<span style=color:#f92672>&lt;</span>Tuple<span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>In the <a href=https://github.com/sam-w-yellin/crunch/blob/24f25f48600b88ea0039ae87b74a35fcda471b1f/include/crunch/messages/crunch_messages.hpp#L86>second case</a> we actually needed to inspect a value inside of each tuple element - the <code>FieldId</code> - so I used the <code>std::make_index_sequence</code> approach.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Tuple<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>concept</span> has_unique_field_ids <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    []<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>size_t... Is<span style=color:#f92672>&gt;</span>(std<span style=color:#f92672>::</span>index_sequence<span style=color:#f92672>&lt;</span>Is...<span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>!</span>has_duplicates<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>remove_cvref_t<span style=color:#f92672>&lt;</span>
</span></span><span style=display:flex><span>            std<span style=color:#f92672>::</span>tuple_element_t<span style=color:#f92672>&lt;</span>Is, Tuple<span style=color:#f92672>&gt;&gt;::</span>field_id...<span style=color:#f92672>&gt;::</span>value;
</span></span><span style=display:flex><span>    }(std<span style=color:#f92672>::</span>make_index_sequence<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>tuple_size_v<span style=color:#f92672>&lt;</span>Tuple<span style=color:#f92672>&gt;&gt;</span>{});
</span></span></code></pre></div><p>I&rsquo;ll briefly touch on the implementation of <code>has_duplicates</code> because it&rsquo;s rather interesting, although not strictly related to the rest of this deep dive. It&rsquo;s implemented like this (only the partial specialization is shown):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span>FieldId Head, FieldId... Tail<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>has_duplicates</span><span style=color:#f92672>&lt;</span>Head, Tail...<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>bool</span> value <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        ((Head <span style=color:#f92672>==</span> Tail) <span style=color:#f92672>||</span> ...) <span style=color:#f92672>||</span> has_duplicates<span style=color:#f92672>&lt;</span>Tail...<span style=color:#f92672>&gt;::</span>value;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>This has the really neat behavior of expanding out an equality check between all elements. First, we expand out comparing the <code>Head</code> element against each other element in the tuple. Then, when we pass in <code>Tail...</code> recursively to <code>has_duplicates</code>, the first element in <code>Tail</code> becomes the next head, and the comparisons continue. At the end, we have checked each element against each other. A quick walkthrough with a concrete set of <code>FieldId</code>s <code>{1, 2, 3}</code>:</p><ol><li>Head == 1, Tail == {2, 3}: 1 == 2 || 1 == 3. Then, OR with the result of call <code>has_duplicates&lt;{2, 3}></code></li><li>Head == 2, Tail == {3}: 2 == 3.</li><li>Combine: 1 == 2 || 1 == 3 || 2 == 3</li></ol><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>Template metaprogramming can be hard to wrap your head around. Moreso than other C++ programming tasks, it can feel like the language is &ldquo;getting in the way&rdquo;. But with enough experience you&rsquo;ll start to be able to break down your desired outcome into achievable steps and compose concepts like the ones we saw today. Hopefully some of these patterns are useful in your own code.</p><p>If you’d like to discuss this pattern or how it might apply to your system, feel free to reach out: <a href=mailto:sam@volatileint.dev>sam@volatileint.dev</a></p><p>If you found this article valuable, consider subscribing to the <a href=https://volatileint.dev/newsletter>newsletter</a> to hear about new posts!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.volatileint.dev/tags/crunch/>Crunch</a></li><li><a href=https://www.volatileint.dev/tags/c++/>C++</a></li><li><a href=https://www.volatileint.dev/tags/template/>Template</a></li><li><a href=https://www.volatileint.dev/tags/tuple/>Tuple</a></li><li><a href=https://www.volatileint.dev/tags/concept/>Concept</a></li><li><a href=https://www.volatileint.dev/tags/tuple-like/>Tuple-Like</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Applying Template Concepts to Tuples in C++ on x" href="https://x.com/intent/tweet/?text=Applying%20Template%20Concepts%20to%20Tuples%20in%20C%2b%2b&amp;url=https%3a%2f%2fwww.volatileint.dev%2fposts%2ftuple-template-concepts%2f&amp;hashtags=crunch%2cC%2b%2b%2ctemplate%2ctuple%2cconcept%2ctuple-like"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Applying Template Concepts to Tuples in C++ on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwww.volatileint.dev%2fposts%2ftuple-template-concepts%2f&amp;title=Applying%20Template%20Concepts%20to%20Tuples%20in%20C%2b%2b&amp;summary=Applying%20Template%20Concepts%20to%20Tuples%20in%20C%2b%2b&amp;source=https%3a%2f%2fwww.volatileint.dev%2fposts%2ftuple-template-concepts%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Applying Template Concepts to Tuples in C++ on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.volatileint.dev%2fposts%2ftuple-template-concepts%2f&title=Applying%20Template%20Concepts%20to%20Tuples%20in%20C%2b%2b"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Applying Template Concepts to Tuples in C++ on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.volatileint.dev%2fposts%2ftuple-template-concepts%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Applying Template Concepts to Tuples in C++ on whatsapp" href="https://api.whatsapp.com/send?text=Applying%20Template%20Concepts%20to%20Tuples%20in%20C%2b%2b%20-%20https%3a%2f%2fwww.volatileint.dev%2fposts%2ftuple-template-concepts%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Applying Template Concepts to Tuples in C++ on telegram" href="https://telegram.me/share/url?text=Applying%20Template%20Concepts%20to%20Tuples%20in%20C%2b%2b&amp;url=https%3a%2f%2fwww.volatileint.dev%2fposts%2ftuple-template-concepts%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Applying Template Concepts to Tuples in C++ on ycombinator" href="https://news.ycombinator.com/submitlink?t=Applying%20Template%20Concepts%20to%20Tuples%20in%20C%2b%2b&u=https%3a%2f%2fwww.volatileint.dev%2fposts%2ftuple-template-concepts%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://www.volatileint.dev/>Volatile Int</a></span> ·
<span><a href=https://www.volatileint.dev/index.xml>Subscribe via RSS</a>
</span>·
<span><a href=https://buttondown.com/volatileint>Subscribe via Newsletter</a>
</span>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0})</script></body></html>