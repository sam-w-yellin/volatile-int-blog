<!doctype html><html lang=en dir=auto data-theme=auto><link rel=stylesheet href=https://www.volatileint.dev/css/custom.css><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Dependency Inversion in C: A Technique for Extensible Embedded Software | Volatile Int</title><meta name=keywords content="C,architecture,embedded,dependency,inversion"><meta name=description content="Learn how to implement dependency inversion in C using function pointer interfaces to decouple high-level logic from implementation details."><meta name=author content><link rel=canonical href=https://www.volatileint.dev/posts/dependency-inversion-c/><link crossorigin=anonymous href=https://www.volatileint.dev/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://www.volatileint.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.volatileint.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.volatileint.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://www.volatileint.dev/apple-touch-icon.png><link rel=mask-icon href=https://www.volatileint.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://www.volatileint.dev/posts/dependency-inversion-c/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-N81PSXWFLZ"></script><script>var doNotTrack=!1,dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes";if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-N81PSXWFLZ")}</script><meta property="og:url" content="https://www.volatileint.dev/posts/dependency-inversion-c/"><meta property="og:site_name" content="Volatile Int"><meta property="og:title" content="Dependency Inversion in C: A Technique for Extensible Embedded Software"><meta property="og:description" content="Learn how to implement dependency inversion in C using function pointer interfaces to decouple high-level logic from implementation details."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-16T12:00:00-08:00"><meta property="article:modified_time" content="2025-11-16T12:00:00-08:00"><meta property="article:tag" content="C"><meta property="article:tag" content="Architecture"><meta property="article:tag" content="Embedded"><meta property="article:tag" content="Dependency"><meta property="article:tag" content="Inversion"><meta name=twitter:card content="summary"><meta name=twitter:title content="Dependency Inversion in C: A Technique for Extensible Embedded Software"><meta name=twitter:description content="Learn how to implement dependency inversion in C using function pointer interfaces to decouple high-level logic from implementation details."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.volatileint.dev/posts/"},{"@type":"ListItem","position":2,"name":"Dependency Inversion in C: A Technique for Extensible Embedded Software","item":"https://www.volatileint.dev/posts/dependency-inversion-c/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Dependency Inversion in C: A Technique for Extensible Embedded Software","name":"Dependency Inversion in C: A Technique for Extensible Embedded Software","description":"Learn how to implement dependency inversion in C using function pointer interfaces to decouple high-level logic from implementation details.","keywords":["C","architecture","embedded","dependency","inversion"],"articleBody":"The core value proposition of software is flexibility - but in embedded systems, we often lose that advantage. Codebases become tightly coupled to a specific hardware revision, making even small platform changes expensive and risky. As hardware complexity grows linearly, software complexity grows exponentially. Costs rise. Schedules slip. Eventually organizations become resistant to improving their own products because the software architecture can’t absorb change.\nThis risk is avoidable. By intentionally separating the high-level business rules from low-level hardware details, we regain the flexibility software is supposed to provide. One of the most effective techniques for achieving this separation is dependency inversion. In short, lower-level components implement an interface defined at a higher level. Control still flows from high to low abstraction layers, but the dependencies flow upward. High-level code is unaware of how the interface is concretely implemented. In an embedded context, this paradigm allows the software architecture to adapt quickly and cheaply to new hardware iterations without rewriting core logic.\nLanguages with full runtime polymorphism natively support this paradigm. They can define abstract base classes from which concrete implementations are derived, and the components depending on these interfaces can depend only on the base class type. C does not have such an elegant built-in solution for inverting dependencies. There is no virtual function table or class hierarchy. But a vtable is just a struct of function pointers - something C expresses naturally. So in C, we provide our own layer of indirection using structs of function pointers.\nIn this post, we explore dependency inversion in C through a concrete, practical example: designing a flexible logging interface.\nA Simple Logger Suppose we’re developing a system in need of a logging facility. The logger needs two APIs:\nAn initialization function to set up any resources required by the logger. A log function that accepts a message to log. A naïve implementation might couple the logger directly to a specific output, like stdout. But this has a serious drawback: it becomes difficult to change how a component logs. What if we wanted a component to sometimes log to stdout, and sometimes log to a file? What if we are working on an embedded platform and need to emit log messages via UART or SPI, or some other serial interface? The solution is dependency inversion.\nLet’s dig into our logger example. The tightly-coupled implementation might look like this, where the the component depends directly or transitively on a specific logger implementation: graph TD Main --\u003e Worker Worker --\u003e StdoutLogger Dependency inversion frees components from needing to know the details of how logging is implemented. It also leads to sparser build dependency graphs - components that depend only on the interface don’t need to be recompiled when implementations change. The resulting architecture looks as follows: graph TD Main --\u003e Worker Main --\u003e StdoutLogger Main --\u003e FileLogger Worker --\u003e LoggerInterface StdoutLogger --\u003e LoggerInterface FileLogger --\u003e LoggerInterface It’s worth noting that it is not only acceptable but expected that main depends on low-level details. Ideally, main - or whatever the entry point for your application is - should be the centralized location where all concrete implementations are defined and injected into the more abstract components.\nDefining the Logger Interface So, let’s define an abstract interface - implemented via function pointers and let the high-level component code depend only on that. A real implementation would probably be a variadic function, but we’ll just log a string for simplicity.\nFile: core/components/logger/include/logger_interface.h #pragma once #include typedef struct logger_interface { void (*init)(void); void (*log)(const char* logger_name, const char *msg); const char* name; } logger_interface_t;\nImplementing Two Concrete Loggers Now, we create two low-level implementations of the high-level logger interface. Notice how they depend on the logger interface. Components which do logging do not directly utilize either of these concrete implementations.\nstdout Logger File: plugins/stdout_logger/include/stdout_logger.h #pragma once #include #include \"logger_interface.h\" logger_interface_t mk_stdout_logger(const char* name); File: plugins/stdout_logger/src/stdout_logger.c #include #include #include \"stdout_logger.h\" static void stdout_logger_init() { } static void stdout_logger_log(const char* logger_name, const char *msg) { printf(\"[%s] %s\\n\", logger_name, msg); } logger_interface_t mk_stdout_logger(const char* name) { logger_interface_t logger; logger.name = name; logger.init = stdout_logger_init; logger.log = stdout_logger_log; return logger; }\nFile Logger File: plugins/file_logger/include/file_logger.h #pragma once #include #include #include \"logger_interface.h\" logger_interface_t mk_file_logger(const char* name); File: plugins/file_logger/src/file_logger.c #include #include #include \"file_logger.h\" static char* logname = \"log.txt\"; static void file_logger_init() { FILE* f = fopen(logname, \"w\"); if (f != NULL) { fclose(f); } } static void file_logger_log(const char* logger_name, const char *msg) { FILE* f = fopen(logname, \"a\"); if (f != NULL) { fprintf(f, \"[%s] %s\\n\", logger_name, msg); fflush(f); fclose(f); } } logger_interface_t mk_file_logger(const char* name) { logger_interface_t logger; logger.name = name; logger.init = file_logger_init; logger.log = file_logger_log; return logger; }\nUsing the Logger in a High-Level Component Let’s create a component that uses a logger. We’ll make a generic worker that does some task - in our case, logs a message. This worker depends only on the logging interface and not a particular logger.\nFile: core/components/worker/include/worker.h #pragma once #include \"logger_interface.h\" typedef struct { const logger_interface_t *logger; } worker_t; void worker_init(worker_t *w, const logger_interface_t *logger); void worker_do_work(worker_t *w);\nFile: core/components/worker/src/worker.c #include #include \"worker.h\" void worker_init(worker_t *w, const logger_interface_t *logger) { w-\u003elogger = logger; w-\u003elogger-\u003einit(); } void worker_do_work(worker_t *w) { w-\u003elogger-\u003elog(w-\u003elogger-\u003ename, \"Worker did some work\"); }\nWiring Together into an Executable It’s now trivial to create a main which instantiates a few different workers, and flexibly select which logger to use. We’ll create three loggers: two that utilize the stdout implementation and one that logs to a file. Each logger instance maintains its own module name buffer, allowing multiple workers to share the same logger implementation while retaining independent module names.\nFile: app/main.c #include #include \"worker.h\" #include \"stdout_logger.h\" #include \"file_logger.h\" int main(void) { logger_interface_t stdout1 = mk_stdout_logger(\"stdout1\"); logger_interface_t stdout2 = mk_stdout_logger(\"stdout2\"); logger_interface_t file1 = mk_file_logger(\"file1\"); worker_t w1, w2, w3; worker_init(\u0026w1, \u0026stdout1); worker_init(\u0026w2, \u0026stdout2); worker_init(\u0026w3, \u0026file1); worker_do_work(\u0026w1); worker_do_work(\u0026w2); worker_do_work(\u0026w3); return 0; }\nIf we compile this all together and run, we should see the two stdout loggers emit their messages on the console, and the file logger’s output in log.txt. The makefile in the source code for this example defines the required target.\nmake \u003e /dev/null ./demo [stdout1] Worker did some work [stdout2] Worker did some work cat log.txt [file1] Worker did some work Verifying Dependency Inversion To confirm the components implementing business logic - like worker - have no dependency on any concrete implementation, let’s investigate the worker object file. If we run make worker.o to create the object file for our worker component, we can then use nm to prove there are no undefined symbols. This demonstrates the dependency inversion worked: the worker component has zero dependency on any concrete logger implementation.\nmake worker.o nm worker.o 0000000000000030 T _worker_do_work 0000000000000000 T _worker_init 000000000000006c s l_.str 0000000000000000 t ltmp0 000000000000006c s ltmp1 0000000000000088 s ltmp2 The Cost of Indirection While this abstraction is very low cost, it is not zero cost. We need to dereference our function pointer, which incurs a small runtime cost each time we log. For almost all applications, this is completely negligible.\nOther Options What are the other options for tackling this sort of problem?\nDefine entirely separate worker components for each logger type: worker-file, worker-stdout, etc Conditionally compile our worker or logger libraries with different implementations depending on the desired configuration. The first bullet is hitting the problem with a hammer - introduce tons of duplication and maintain tightly coupled interfaces. This makes the project much more expensive to maintain and less scalable. The second option is even worse - we’ve made it impossible to instantiate multiple types of loggers in a single translation unit. It’s my opinion that conditional compilation is nearly always a code smell and should be avoided at all costs - a topic for another time. In short, both alternatives reduce flexibility and maintainability compared to dependency inversion.\nConclusion We’ve now walked through implementing dependency inversion in C - a language without native support for dynamic polymorphism. Using function-pointer interfaces allows you to decouple high-level policy from hardware-specific implementations with minimal overhead. This pattern produces more testable, more portable, and more maintainable embedded systems.\nThe full source code for this example is available on GitHub. If you’d like to discuss this pattern or how it might apply to your system, feel free to reach out: sam@volatileint.dev\nIf you found this article valuable, consider subscribing to the newsletter to hear about new posts!\n","wordCount":"1405","inLanguage":"en","datePublished":"2025-11-16T12:00:00-08:00","dateModified":"2025-11-16T12:00:00-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.volatileint.dev/posts/dependency-inversion-c/"},"publisher":{"@type":"Organization","name":"Volatile Int","logo":{"@type":"ImageObject","url":"https://www.volatileint.dev/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://www.volatileint.dev/ accesskey=h title="  (Alt + H)"><img src=https://www.volatileint.dev/images/top-logo-light.svg alt aria-label=logo height=32></a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.volatileint.dev/about/ title=About><span>About</span></a></li><li><a href=https://www.volatileint.dev/newsletter/ title=Newsletter><span>Newsletter</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Dependency Inversion in C: A Technique for Extensible Embedded Software</h1><div class=post-description>Learn how to implement dependency inversion in C using function pointer interfaces to decouple high-level logic from implementation details.</div><div class=post-meta><span title='2025-11-16 12:00:00 -0800 -0800'>November 16, 2025</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#a-simple-logger aria-label="A Simple Logger">A Simple Logger</a></li><li><a href=#defining-the-logger-interface aria-label="Defining the Logger Interface">Defining the Logger Interface</a><ul><li><a href=#implementing-two-concrete-loggers aria-label="Implementing Two Concrete Loggers">Implementing Two Concrete Loggers</a><ul><li><a href=#stdout-logger aria-label="stdout Logger">stdout Logger</a></li><li><a href=#file-logger aria-label="File Logger">File Logger</a></li></ul></li></ul></li><li><a href=#using-the-logger-in-a-high-level-component aria-label="Using the Logger in a High-Level Component">Using the Logger in a High-Level Component</a></li><li><a href=#wiring-together-into-an-executable aria-label="Wiring Together into an Executable">Wiring Together into an Executable</a></li><li><a href=#verifying-dependency-inversion aria-label="Verifying Dependency Inversion">Verifying Dependency Inversion</a></li><li><a href=#the-cost-of-indirection aria-label="The Cost of Indirection">The Cost of Indirection</a></li><li><a href=#other-options aria-label="Other Options">Other Options</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><p>The core value proposition of software is flexibility - but in embedded systems, we often lose that advantage. Codebases become tightly coupled to a specific hardware revision, making even small platform changes expensive and risky. As hardware complexity grows linearly, software complexity grows exponentially. Costs rise. Schedules slip. Eventually organizations become resistant to improving their own products because the software architecture can’t absorb change.</p><p>This risk is avoidable. By intentionally separating the high-level business rules from low-level hardware details, we regain the flexibility software is supposed to provide. One of the most effective techniques for achieving this separation is <a href=https://en.wikipedia.org/wiki/Dependency_inversion_principle>dependency inversion</a>. In short, lower-level components implement an interface defined at a higher level. Control still flows from high to low abstraction layers, but the <em>dependencies</em> flow upward. High-level code is unaware of how the interface is concretely implemented. In an embedded context, this paradigm allows the software architecture to adapt quickly and cheaply to new hardware iterations without rewriting core logic.</p><p>Languages with full runtime polymorphism natively support this paradigm. They can define abstract base classes from which concrete implementations are derived, and the components depending on these interfaces can depend only on the base class type. C does not have such an elegant built-in solution for inverting dependencies. There is no virtual function table or class hierarchy. But a vtable is just a struct of function pointers - something C expresses naturally. So in C, we provide our own layer of indirection using structs of function pointers.</p><p>In this post, we explore dependency inversion in C through a concrete, practical example: designing a flexible logging interface.</p><h2 id=a-simple-logger>A Simple Logger<a hidden class=anchor aria-hidden=true href=#a-simple-logger>#</a></h2><p>Suppose we’re developing a system in need of a logging facility. The logger needs two APIs:</p><ol><li>An initialization function to set up any resources required by the logger.</li><li>A log function that accepts a message to log.</li></ol><p>A naïve implementation might couple the logger directly to a specific output, like stdout. But this has a serious drawback: it becomes difficult to change <em>how</em> a component logs. What if we wanted a component to sometimes log to stdout, and sometimes log to a file? What if we are working on an embedded platform and need to emit log messages via UART or SPI, or some other serial interface? The solution is dependency inversion.</p><p>Let’s dig into our logger example. The tightly-coupled implementation might look like this, where the the component depends directly or transitively on a specific logger implementation:<div class=mermaid-box><div class=mermaid>graph TD
Main --> Worker
Worker --> StdoutLogger</div></div></p><p>Dependency inversion frees components from needing to know the details of how logging is implemented. It also leads to sparser build dependency graphs - components that depend only on the interface don’t need to be recompiled when implementations change. The resulting architecture looks as follows:<div class=mermaid-box><div class=mermaid>graph TD
Main --> Worker
Main --> StdoutLogger
Main --> FileLogger
Worker --> LoggerInterface
StdoutLogger --> LoggerInterface
FileLogger --> LoggerInterface</div></div></p><p>It’s worth noting that it is not only acceptable but expected that main depends on low-level details. Ideally, <code>main</code> - or whatever the entry point for your application is - should be the centralized location where all concrete implementations are defined and injected into the more abstract components.</p><h2 id=defining-the-logger-interface>Defining the Logger Interface<a hidden class=anchor aria-hidden=true href=#defining-the-logger-interface>#</a></h2><p>So, let&rsquo;s define an abstract interface - implemented via function pointers and let the high-level component code depend only on that. A real implementation would probably be a variadic function, but we&rsquo;ll just log a string for simplicity.</p><p><strong>File</strong>: <code>core/components/logger/include/logger_interface.h</code><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#pragma once
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stddef.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> logger_interface 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>init)(<span style=color:#66d9ef>void</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>log)(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> logger_name, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>msg);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> name;
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>logger_interface_t</span>;</span></span></code></pre></div></p><h3 id=implementing-two-concrete-loggers>Implementing Two Concrete Loggers<a hidden class=anchor aria-hidden=true href=#implementing-two-concrete-loggers>#</a></h3><p>Now, we create two low-level implementations of the high-level logger interface. Notice how they depend on the logger interface. Components which do logging do not directly utilize either of these concrete implementations.</p><h4 id=stdout-logger>stdout Logger<a hidden class=anchor aria-hidden=true href=#stdout-logger>#</a></h4><p><strong>File</strong>: <code>plugins/stdout_logger/include/stdout_logger.h</code><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#pragma once
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stddef.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;logger_interface.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>logger_interface_t</span> <span style=color:#a6e22e>mk_stdout_logger</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> name);</span></span></code></pre></div><strong>File</strong>: <code>plugins/stdout_logger/src/stdout_logger.c</code><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;stdout_logger.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>stdout_logger_init</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>stdout_logger_log</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> logger_name, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>msg)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[%s] %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, logger_name, msg);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>logger_interface_t</span> <span style=color:#a6e22e>mk_stdout_logger</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> name) 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logger_interface_t</span> logger;
</span></span><span style=display:flex><span>    logger.name <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>    logger.init <span style=color:#f92672>=</span> stdout_logger_init;
</span></span><span style=display:flex><span>    logger.log <span style=color:#f92672>=</span> stdout_logger_log;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> logger;
</span></span><span style=display:flex><span>}</span></span></code></pre></div></p><h4 id=file-logger>File Logger<a hidden class=anchor aria-hidden=true href=#file-logger>#</a></h4><p><strong>File</strong>: <code>plugins/file_logger/include/file_logger.h</code><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#pragma once
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stddef.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;logger_interface.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>logger_interface_t</span> <span style=color:#a6e22e>mk_file_logger</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> name);</span></span></code></pre></div><strong>File</strong>: <code>plugins/file_logger/src/file_logger.c</code><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;file_logger.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> logname <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;log.txt&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>file_logger_init</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    FILE<span style=color:#f92672>*</span> f <span style=color:#f92672>=</span> <span style=color:#a6e22e>fopen</span>(logname, <span style=color:#e6db74>&#34;w&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (f <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fclose</span>(f);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>file_logger_log</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> logger_name, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>msg)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    FILE<span style=color:#f92672>*</span> f <span style=color:#f92672>=</span> <span style=color:#a6e22e>fopen</span>(logname, <span style=color:#e6db74>&#34;a&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (f <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fprintf</span>(f, <span style=color:#e6db74>&#34;[%s] %s</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, logger_name, msg);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fflush</span>(f);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fclose</span>(f);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>logger_interface_t</span> <span style=color:#a6e22e>mk_file_logger</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> name) 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logger_interface_t</span> logger;
</span></span><span style=display:flex><span>    logger.name <span style=color:#f92672>=</span> name;
</span></span><span style=display:flex><span>    logger.init <span style=color:#f92672>=</span> file_logger_init;
</span></span><span style=display:flex><span>    logger.log <span style=color:#f92672>=</span> file_logger_log;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> logger;
</span></span><span style=display:flex><span>}</span></span></code></pre></div></p><h2 id=using-the-logger-in-a-high-level-component>Using the Logger in a High-Level Component<a hidden class=anchor aria-hidden=true href=#using-the-logger-in-a-high-level-component>#</a></h2><p>Let&rsquo;s create a component that uses a logger. We&rsquo;ll make a generic worker that does some task - in our case, logs a message. This worker depends only on the logging <em>interface</em> and not a particular logger.</p><p><strong>File</strong>: <code>core/components/worker/include/worker.h</code><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#pragma once
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;logger_interface.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>logger_interface_t</span> <span style=color:#f92672>*</span>logger;
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>worker_t</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>worker_init</span>(<span style=color:#66d9ef>worker_t</span> <span style=color:#f92672>*</span>w,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>logger_interface_t</span> <span style=color:#f92672>*</span>logger);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>worker_do_work</span>(<span style=color:#66d9ef>worker_t</span> <span style=color:#f92672>*</span>w);</span></span></code></pre></div></p><p><strong>File</strong>: <code>core/components/worker/src/worker.c</code><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;worker.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>worker_init</span>(<span style=color:#66d9ef>worker_t</span> <span style=color:#f92672>*</span>w,
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>logger_interface_t</span> <span style=color:#f92672>*</span>logger)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    w<span style=color:#f92672>-&gt;</span>logger <span style=color:#f92672>=</span> logger;
</span></span><span style=display:flex><span>    w<span style=color:#f92672>-&gt;</span>logger<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>init</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>worker_do_work</span>(<span style=color:#66d9ef>worker_t</span> <span style=color:#f92672>*</span>w)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    w<span style=color:#f92672>-&gt;</span>logger<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>log</span>(w<span style=color:#f92672>-&gt;</span>logger<span style=color:#f92672>-&gt;</span>name, <span style=color:#e6db74>&#34;Worker did some work&#34;</span>);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></p><h2 id=wiring-together-into-an-executable>Wiring Together into an Executable<a hidden class=anchor aria-hidden=true href=#wiring-together-into-an-executable>#</a></h2><p>It&rsquo;s now trivial to create a <code>main</code> which instantiates a few different workers, and flexibly select which logger to use. We&rsquo;ll create three loggers: two that utilize the stdout implementation and one that logs to a file. Each logger instance maintains its own module name buffer, allowing multiple workers to share the same logger implementation while retaining independent module names.</p><p><strong>File</strong>: <code>app/main.c</code><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;worker.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;stdout_logger.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;file_logger.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logger_interface_t</span> stdout1 <span style=color:#f92672>=</span> <span style=color:#a6e22e>mk_stdout_logger</span>(<span style=color:#e6db74>&#34;stdout1&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logger_interface_t</span> stdout2 <span style=color:#f92672>=</span> <span style=color:#a6e22e>mk_stdout_logger</span>(<span style=color:#e6db74>&#34;stdout2&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>logger_interface_t</span> file1 <span style=color:#f92672>=</span> <span style=color:#a6e22e>mk_file_logger</span>(<span style=color:#e6db74>&#34;file1&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>worker_t</span> w1, w2, w3;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>worker_init</span>(<span style=color:#f92672>&amp;</span>w1, <span style=color:#f92672>&amp;</span>stdout1);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>worker_init</span>(<span style=color:#f92672>&amp;</span>w2, <span style=color:#f92672>&amp;</span>stdout2);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>worker_init</span>(<span style=color:#f92672>&amp;</span>w3, <span style=color:#f92672>&amp;</span>file1);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>worker_do_work</span>(<span style=color:#f92672>&amp;</span>w1);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>worker_do_work</span>(<span style=color:#f92672>&amp;</span>w2);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>worker_do_work</span>(<span style=color:#f92672>&amp;</span>w3);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}</span></span></code></pre></div></p><p>If we compile this all together and run, we should see the two stdout loggers emit their messages on the console, and the file logger&rsquo;s output in <code>log.txt</code>. The makefile in the source code for this example defines the required target.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>make &gt; /dev/null
</span></span><span style=display:flex><span>./demo
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>stdout1<span style=color:#f92672>]</span> Worker did some work
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>stdout2<span style=color:#f92672>]</span> Worker did some work
</span></span><span style=display:flex><span>cat log.txt
</span></span><span style=display:flex><span><span style=color:#f92672>[</span>file1<span style=color:#f92672>]</span> Worker did some work
</span></span></code></pre></div><h2 id=verifying-dependency-inversion>Verifying Dependency Inversion<a hidden class=anchor aria-hidden=true href=#verifying-dependency-inversion>#</a></h2><p>To confirm the components implementing business logic - like <code>worker</code> - have no dependency on any concrete implementation, let&rsquo;s investigate the <code>worker</code> object file. If we run <code>make worker.o</code> to create the object file for our worker component, we can then use <code>nm</code> to prove there are no undefined symbols. This demonstrates the dependency inversion worked: the worker component has zero dependency on any concrete logger implementation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-bash data-lang=bash><span style=display:flex><span>make worker.o
</span></span><span style=display:flex><span>nm worker.o
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000000000000030</span> T _worker_do_work
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000000000000000</span> T _worker_init
</span></span><span style=display:flex><span>000000000000006c s l_.str
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000000000000000</span> t ltmp0
</span></span><span style=display:flex><span>000000000000006c s ltmp1
</span></span><span style=display:flex><span><span style=color:#ae81ff>0000000000000088</span> s ltmp2
</span></span></code></pre></div><h2 id=the-cost-of-indirection>The Cost of Indirection<a hidden class=anchor aria-hidden=true href=#the-cost-of-indirection>#</a></h2><p>While this abstraction is very low cost, it is not <em>zero</em> cost. We need to dereference our function pointer, which incurs a small runtime cost each time we log. For almost all applications, this is completely negligible.</p><h2 id=other-options>Other Options<a hidden class=anchor aria-hidden=true href=#other-options>#</a></h2><p>What are the other options for tackling this sort of problem?</p><ol><li>Define entirely separate worker components for each logger type: worker-file, worker-stdout, etc</li><li>Conditionally compile our worker or logger libraries with different implementations depending on the desired configuration.</li></ol><p>The first bullet is hitting the problem with a hammer - introduce tons of duplication and maintain tightly coupled interfaces. This makes the project much more expensive to maintain and less scalable. The second option is even worse - we&rsquo;ve made it impossible to instantiate multiple types of loggers in a single translation unit. It&rsquo;s my opinion that conditional compilation is nearly always a code smell and should be avoided at all costs - a topic for another time. In short, both alternatives reduce flexibility and maintainability compared to dependency inversion.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>We’ve now walked through implementing dependency inversion in C - a language without native support for dynamic polymorphism. Using function-pointer interfaces allows you to decouple high-level policy from hardware-specific implementations with minimal overhead. This pattern produces more testable, more portable, and more maintainable embedded systems.</p><p>The full source code for this example is available on <a href=https://github.com/sam-w-yellin/dependency-inversion-c>GitHub</a>. If you’d like to discuss this pattern or how it might apply to your system, feel free to reach out: <a href=mailto:sam@volatileint.dev>sam@volatileint.dev</a></p><p>If you found this article valuable, consider subscribing to the <a href=https://volatileint.dev/newsletter>newsletter</a> to hear about new posts!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.volatileint.dev/tags/c/>C</a></li><li><a href=https://www.volatileint.dev/tags/architecture/>Architecture</a></li><li><a href=https://www.volatileint.dev/tags/embedded/>Embedded</a></li><li><a href=https://www.volatileint.dev/tags/dependency/>Dependency</a></li><li><a href=https://www.volatileint.dev/tags/inversion/>Inversion</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Dependency Inversion in C: A Technique for Extensible Embedded Software on x" href="https://x.com/intent/tweet/?text=Dependency%20Inversion%20in%20C%3a%20A%20Technique%20for%20Extensible%20Embedded%20Software&amp;url=https%3a%2f%2fwww.volatileint.dev%2fposts%2fdependency-inversion-c%2f&amp;hashtags=C%2carchitecture%2cembedded%2cdependency%2cinversion"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Dependency Inversion in C: A Technique for Extensible Embedded Software on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwww.volatileint.dev%2fposts%2fdependency-inversion-c%2f&amp;title=Dependency%20Inversion%20in%20C%3a%20A%20Technique%20for%20Extensible%20Embedded%20Software&amp;summary=Dependency%20Inversion%20in%20C%3a%20A%20Technique%20for%20Extensible%20Embedded%20Software&amp;source=https%3a%2f%2fwww.volatileint.dev%2fposts%2fdependency-inversion-c%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Dependency Inversion in C: A Technique for Extensible Embedded Software on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.volatileint.dev%2fposts%2fdependency-inversion-c%2f&title=Dependency%20Inversion%20in%20C%3a%20A%20Technique%20for%20Extensible%20Embedded%20Software"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Dependency Inversion in C: A Technique for Extensible Embedded Software on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.volatileint.dev%2fposts%2fdependency-inversion-c%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Dependency Inversion in C: A Technique for Extensible Embedded Software on whatsapp" href="https://api.whatsapp.com/send?text=Dependency%20Inversion%20in%20C%3a%20A%20Technique%20for%20Extensible%20Embedded%20Software%20-%20https%3a%2f%2fwww.volatileint.dev%2fposts%2fdependency-inversion-c%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Dependency Inversion in C: A Technique for Extensible Embedded Software on telegram" href="https://telegram.me/share/url?text=Dependency%20Inversion%20in%20C%3a%20A%20Technique%20for%20Extensible%20Embedded%20Software&amp;url=https%3a%2f%2fwww.volatileint.dev%2fposts%2fdependency-inversion-c%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Dependency Inversion in C: A Technique for Extensible Embedded Software on ycombinator" href="https://news.ycombinator.com/submitlink?t=Dependency%20Inversion%20in%20C%3a%20A%20Technique%20for%20Extensible%20Embedded%20Software&u=https%3a%2f%2fwww.volatileint.dev%2fposts%2fdependency-inversion-c%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://www.volatileint.dev/>Volatile Int</a></span> ·
<span><a href=https://www.volatileint.dev/index.xml>Subscribe via RSS</a>
</span>·
<span><a href=https://buttondown.com/volatileint>Subscribe via Newsletter</a>
</span>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0})</script></body></html>