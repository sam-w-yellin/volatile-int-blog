<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">
<link rel="stylesheet" href="https://www.volatileint.dev/css/custom.css">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Can you survive the C&#43;&#43; Auto Type Gauntlet? | Volatile Int</title>
<meta name="keywords" content="C&#43;&#43;, type, deduction, auto, quiz">
<meta name="description" content="One of the most iconic C&#43;&#43; features is the language&rsquo;s ability to deduce types with the auto keyword. In this post, I&rsquo;ll give a bunch of example code snippits. Your job is to assess what will be deduced for v in each snippit. Determine:

The type
If it is a reference or not
CV qualifiers

Some of these may not even compile, so &ldquo;this won&rsquo;t work&rdquo; is a totally valid answer.">
<meta name="author" content="">
<link rel="canonical" href="https://www.volatileint.dev/posts/auto-type-deduction-gauntlet/">
<link crossorigin="anonymous" href="https://www.volatileint.dev/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css" integrity="sha256-NDzEgLn/yPBMy&#43;XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://www.volatileint.dev/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.volatileint.dev/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.volatileint.dev/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://www.volatileint.dev/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.volatileint.dev/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://www.volatileint.dev/posts/auto-type-deduction-gauntlet/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-N81PSXWFLZ"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-N81PSXWFLZ');
        }
      </script><meta property="og:url" content="https://www.volatileint.dev/posts/auto-type-deduction-gauntlet/">
  <meta property="og:site_name" content="Volatile Int">
  <meta property="og:title" content="Can you survive the C&#43;&#43; Auto Type Gauntlet?">
  <meta property="og:description" content="One of the most iconic C&#43;&#43; features is the language’s ability to deduce types with the auto keyword. In this post, I’ll give a bunch of example code snippits. Your job is to assess what will be deduced for v in each snippit. Determine:
The type If it is a reference or not CV qualifiers Some of these may not even compile, so “this won’t work” is a totally valid answer.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-12-05T12:00:00-08:00">
    <meta property="article:modified_time" content="2025-12-05T12:00:00-08:00">
    <meta property="article:tag" content="C&#43;&#43;">
    <meta property="article:tag" content="Type">
    <meta property="article:tag" content="Deduction">
    <meta property="article:tag" content="Auto">
    <meta property="article:tag" content="Quiz">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Can you survive the C&#43;&#43; Auto Type Gauntlet?">
<meta name="twitter:description" content="One of the most iconic C&#43;&#43; features is the language&rsquo;s ability to deduce types with the auto keyword. In this post, I&rsquo;ll give a bunch of example code snippits. Your job is to assess what will be deduced for v in each snippit. Determine:

The type
If it is a reference or not
CV qualifiers

Some of these may not even compile, so &ldquo;this won&rsquo;t work&rdquo; is a totally valid answer.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://www.volatileint.dev/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Can you survive the C++ Auto Type Gauntlet?",
      "item": "https://www.volatileint.dev/posts/auto-type-deduction-gauntlet/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Can you survive the C++ Auto Type Gauntlet?",
  "name": "Can you survive the C\u002b\u002b Auto Type Gauntlet?",
  "description": "One of the most iconic C++ features is the language\u0026rsquo;s ability to deduce types with the auto keyword. In this post, I\u0026rsquo;ll give a bunch of example code snippits. Your job is to assess what will be deduced for v in each snippit. Determine:\nThe type If it is a reference or not CV qualifiers Some of these may not even compile, so \u0026ldquo;this won\u0026rsquo;t work\u0026rdquo; is a totally valid answer.\n",
  "keywords": [
    "C++", "type", "deduction", "auto", "quiz"
  ],
  "articleBody": "One of the most iconic C++ features is the language’s ability to deduce types with the auto keyword. In this post, I’ll give a bunch of example code snippits. Your job is to assess what will be deduced for v in each snippit. Determine:\nThe type If it is a reference or not CV qualifiers Some of these may not even compile, so “this won’t work” is a totally valid answer.\nEach section increases in difficulty. Good luck!\nThe Gauntlet Basics Basic assignments and deduction from constants and straightforward types.\nauto v = 5; Answer Type: int Explanation: Straightforward type deduction from an integer constant. auto v = 0.1; Answer Type: double Explanation: Notably different than integers. Floating points default to the larger double instead of float. int x; auto v = x; Answer Type: int Explanation: Integer type derived from the assigned-from variable. auto v = 5, w = 0.1; Answer Type: Fails to compile. Explanation: All types in an expression defined with auto have to be the same. std::pair x {1, 2.0}; auto [v, w] = x; Answer Type: int Explanation: Unless, of course, you are using structured binding. int x; auto v = \u0026x; Answer Type: int* Explanation: Auto will deduce pointers. auto v = nullptr; Answer Type: std::nullptr_t Explanation: nullptr has its own type auto v = { 1, 2, 3 }; Answer Type: std::initializer_list Explanation: It might seem like this should create a container, but it won’t! int x[5]; auto v = x; Answer Type: int* Explanation: C-style arrays decay to a pointer. The decay happens before auto is evaluated. int foo(int x) { return x; } auto v = foo; Answer Type: int (*) (int) Explanation: auto can deduce function pointers. Intermediate Exploring how references and CV-qualifiers are handled. volatile const int x = 1; auto v = x; Answer Type: int Explanation: auto drops CV qualifiers. volatile const int x = 1; auto v = \u0026x; Answer Type: volatile const int* Explanation: Unless, of course, they are applied to a pointed-to or reference type int x; int\u0026 y = x; auto v = y; Answer Type: int Explanation: auto will never deduce a reference on its own. int x; auto\u0026 v = x; Answer Type: int\u0026 Explanation: References are inferred if explicitly marked as a reference. int x[5]; auto\u0026 v = x; Answer Type: int (\u0026) [5] Explanation: When binding arrays to references, they don’t decay. So, auto deduces the actual array type. int foo(const int x) { return x; } auto v = foo; Answer Type: int (*) (int) Explanation: Remember - CV qualifiers are thrown away during function resolution! Advanced Forwarding references, decltype(auto), and lambdas.\nint x; auto\u0026\u0026 v = x; Answer Type: int\u0026 Explanation: A forwarding reference like auto\u0026\u0026 can bind to lvalue or rvalue expressions. We get an lvalue reference because x is an lvalue. auto x = [] () -\u003e int { return 1; }; auto\u0026\u0026 v = x(); Answer Type: int\u0026\u0026 Explanation: x() returns a prvalue, and prvalues assigned to forwarding references result in an rvalue reference. int x; auto y = [\u0026] () -\u003e int\u0026 { return x; }; auto\u0026\u0026 v = y(); Answer Type: int\u0026 Explanation: This time x() returns an lvalue, and lvalues assigned to forwarding references result in an lvalue reference. int x; decltype(auto) v = (x); Answer Type: int\u0026 Explanation: (x) is an expression. decltype(expression) yields a reference when the expression is an lvalue. struct Foo {}; auto\u0026\u0026 v = Foo{}; Answer Type: Foo\u0026\u0026 Explanation: prvalues like Foo{} will bind to a rvalue reference. struct Foo {}; decltype(auto) v = Foo{}; Answer Type: Foo Explanation: For any prvalue expression e, decltype(e) evaluates to the type of e. int x; decltype(auto) v = std::move(x); Answer Type: int\u0026\u0026 Explanation: For any xvalue expression e, decltype(e) evalutes to a rvalue reference to the type of e. int foo(int x) { return x; } decltype(auto) v = foo; Answer Type: Fails to compile. Explanation: Function id-expressions do not decay to pointers when evaluating with decltype! int foo(int x) { return x; } decltype(auto) v = (foo); Answer Type: Fails to compile. Explanation: Parenthesized function symbol expressions do decay to function pointers with decltype. Oof Abandon all hope, ye who attempt to deduce the types of lambda captures in expressions with decltype(auto).\nint x; [\u0026] { decltype(auto) v = x; } Answer Type: int Explanation: x is captured by reference, but decltype(auto) deduces id-expressions only by type. int x; [\u0026] { decltype(auto) v = (x); } Answer Type: int\u0026 Explanation: x is captured by reference, parenthesized expressions maintain their references with decltype(auto). int x; [=] { decltype(auto) v = x; } Answer Type: int Explanation: Similar to above - decltype(auto) deduces id-expressions only by type. int x; [=] { decltype(auto) v = (x); } Answer Type: const int\u0026 Explanation: Captures by value are const, and we are evaluting a non-id expression. int x; [=] mutable { decltype(auto) v = (x); } Answer Type: int\u0026 Explanation: Unless, of course, we make the lambda mutable. Then the captures are non-const. int x; int\u0026 y = x; [=] () { decltype(auto) v = y; }(); Answer Type: Fails to compile. Explanation: y is an int\u0026 outside the lambda. But inside the lambda, it is a const int\u0026. This fails because we are discarding the captured y’s const qualifier. Conclusion You can check any of these by using this GodBolt link. Shoutout to this Stack Overflow thread which provided the code snippit to print human readable names for a variable.\nDo you have any interesting examples to share? Reach out at sam@volatileint.dev and let me know!\n",
  "wordCount" : "935",
  "inLanguage": "en",
  "datePublished": "2025-12-05T12:00:00-08:00",
  "dateModified": "2025-12-05T12:00:00-08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.volatileint.dev/posts/auto-type-deduction-gauntlet/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Volatile Int",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.volatileint.dev/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.volatileint.dev/" accesskey="h" title="Volatile Int (Alt + H)">Volatile Int</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.volatileint.dev/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://www.volatileint.dev/newsletter/" title="Newsletter">
                    <span>Newsletter</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Can you survive the C&#43;&#43; Auto Type Gauntlet?
    </h1>
    <div class="post-meta"><span title='2025-12-05 12:00:00 -0800 PST'>December 5, 2025</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#the-gauntlet" aria-label="The Gauntlet">The Gauntlet</a><ul>
                        
                <li>
                    <a href="#basics" aria-label="Basics">Basics</a></li>
                <li>
                    <a href="#intermediate" aria-label="Intermediate">Intermediate</a></li>
                <li>
                    <a href="#advanced" aria-label="Advanced">Advanced</a></li>
                <li>
                    <a href="#oof" aria-label="Oof">Oof</a></li></ul>
                </li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>One of the most iconic C++ features is the language&rsquo;s ability to deduce types with the <code>auto</code> keyword. In this post, I&rsquo;ll give a bunch of example code snippits. Your job is to assess what will be deduced for <code>v</code> in each snippit. Determine:</p>
<ol>
<li>The type</li>
<li>If it is a reference or not</li>
<li>CV qualifiers</li>
</ol>
<p>Some of these may not even compile, so &ldquo;this won&rsquo;t work&rdquo; is a totally valid answer.</p>
<p>Each section increases in difficulty. Good luck!</p>
<h1 id="the-gauntlet">The Gauntlet<a hidden class="anchor" aria-hidden="true" href="#the-gauntlet">#</a></h1>
<h2 id="basics">Basics<a hidden class="anchor" aria-hidden="true" href="#basics">#</a></h2>
<p>Basic assignments and deduction from constants and straightforward types.</p>
<div class="auto-quiz-block">
  <pre><code>
auto v = 5;
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>int</code>
      <br>
      <strong>Explanation:</strong> Straightforward type deduction from an integer constant.
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
auto v = 0.1;
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>double</code>
      <br>
      <strong>Explanation:</strong> Notably different than integers. Floating points default to the larger <code>double</code> instead of <code>float</code>.
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
int x;
auto v = x;
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>int</code>
      <br>
      <strong>Explanation:</strong> Integer type derived from the assigned-from variable.
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
auto v = 5, w = 0.1;
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> Fails to compile.
      <br>
      <strong>Explanation:</strong> All types in an expression defined with <code>auto</code> have to be the same.
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
std::pair<int, float> x {1, 2.0};
auto [v, w] = x;
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> int
      <br>
      <strong>Explanation:</strong> Unless, of course, you are using structured binding.
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
int x;
auto v = &x;
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>int*</code>
      <br>
      <strong>Explanation:</strong> Auto will deduce pointers.
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
auto v = nullptr;
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>std::nullptr_t</code>
      <br>
      <strong>Explanation:</strong> nullptr has its own type
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
auto v = { 1, 2, 3 };
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>std::initializer_list&lt;int&gt;</code>
      <br>
      <strong>Explanation:</strong> It might seem like this should create a container, but it won&rsquo;t!
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
int x[5];
auto v = x;
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>int*</code>
      <br>
      <strong>Explanation:</strong> C-style arrays decay to a pointer. The decay happens before <code>auto</code> is evaluated.
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
int foo(int x) {
    return x;
}
auto v = foo;
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>int (*) (int)</code>
      <br>
      <strong>Explanation:</strong>  <code>auto</code> can deduce function pointers.
    </div>
  </details>
</div>
<h2 id="intermediate">Intermediate<a hidden class="anchor" aria-hidden="true" href="#intermediate">#</a></h2>
<p>Exploring how references and CV-qualifiers are handled.
<div class="auto-quiz-block">
  <pre><code>
volatile const int x = 1;
auto v = x;
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>int</code>
      <br>
      <strong>Explanation:</strong> <code>auto</code> drops CV qualifiers.
    </div>
  </details>
</div></p>
<div class="auto-quiz-block">
  <pre><code>
volatile const int x = 1;
auto v = &x;
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>volatile const int*</code>
      <br>
      <strong>Explanation:</strong> Unless, of course, they are applied to a pointed-to or reference type
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
int x;
int& y = x;
auto v = y;
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>int</code>
      <br>
      <strong>Explanation:</strong> <code>auto</code> will never deduce a reference on its own.
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
int x;
auto& v = x;
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>int&amp;</code>
      <br>
      <strong>Explanation:</strong> References are inferred if explicitly marked as a reference.
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
int x[5];
auto& v = x;
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>int (&amp;) [5]</code>
      <br>
      <strong>Explanation:</strong> When binding arrays to references, they don&rsquo;t decay. So, <code>auto</code> deduces the actual array type.
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
int foo(const int x) {
    return x;
}
auto v = foo;
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>int (*) (int)</code>
      <br>
      <strong>Explanation:</strong>  Remember - CV qualifiers are thrown away during function resolution!
    </div>
  </details>
</div>
<h2 id="advanced">Advanced<a hidden class="anchor" aria-hidden="true" href="#advanced">#</a></h2>
<p>Forwarding references, <code>decltype(auto)</code>, and lambdas.</p>
<div class="auto-quiz-block">
  <pre><code>
int x;
auto&& v = x;
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>int&amp;</code>
      <br>
      <strong>Explanation:</strong> A forwarding reference like <code>auto&amp;&amp;</code> can bind to lvalue or rvalue expressions. We get an lvalue reference because <code>x</code> is an lvalue.
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
auto x = [] () -> int { 
    return 1;
};
auto&& v = x();
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>int&amp;&amp;</code>
      <br>
      <strong>Explanation:</strong> <code>x()</code> returns a prvalue, and prvalues assigned to forwarding references result in an rvalue reference.
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
int x;
auto y = [&] () -> int& { 
    return x;
};
auto&& v = y();
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>int&amp;</code>
      <br>
      <strong>Explanation:</strong> This time <code>x()</code> returns an lvalue, and lvalues assigned to forwarding references result in an lvalue reference.
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
int x;
decltype(auto) v = (x);
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>int&amp;</code>
      <br>
      <strong>Explanation:</strong> <code>(x)</code> is an expression. <code>decltype(expression)</code> yields a reference when the expression is an lvalue.
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
struct Foo {};
auto&& v = Foo{};
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>Foo&amp;&amp;</code>
      <br>
      <strong>Explanation:</strong> prvalues like Foo{} will bind to a rvalue reference.
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
struct Foo {};
decltype(auto) v = Foo{};
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>Foo</code>
      <br>
      <strong>Explanation:</strong> For any prvalue expression <code>e</code>, <code>decltype(e)</code> evaluates to the <em>type</em> of e.
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
int x;
decltype(auto) v = std::move(x);
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>int&amp;&amp;</code>
      <br>
      <strong>Explanation:</strong> For any xvalue expression <code>e</code>, <code>decltype(e)</code> evalutes to a rvalue reference to the type of e.
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
int foo(int x) {
    return x;
}
decltype(auto) v = foo;
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> Fails to compile.
      <br>
      <strong>Explanation:</strong>  Function id-expressions do not decay to pointers when evaluating with <code>decltype</code>!
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
int foo(int x) {
    return x;
}
decltype(auto) v = (foo);
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> Fails to compile.
      <br>
      <strong>Explanation:</strong>  Parenthesized function symbol expressions <em>do</em> decay to function pointers with <code>decltype</code>.
    </div>
  </details>
</div>
<h2 id="oof">Oof<a hidden class="anchor" aria-hidden="true" href="#oof">#</a></h2>
<p>Abandon all hope, ye who attempt to deduce the types of lambda captures in expressions with <code>decltype(auto)</code>.</p>
<div class="auto-quiz-block">
  <pre><code>
int x;
[&] {
    decltype(auto) v = x;
}
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>int</code>
      <br>
      <strong>Explanation:</strong> <code>x</code> is captured by reference, but <code>decltype(auto)</code> deduces id-expressions only by type.
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
int x;
[&] {
    decltype(auto) v = (x);
}
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>int&amp;</code>
      <br>
      <strong>Explanation:</strong> <code>x</code> is captured by reference, parenthesized expressions maintain their references with <code>decltype(auto)</code>.
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
int x;
[=] {
    decltype(auto) v = x;
}
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>int</code>
      <br>
      <strong>Explanation:</strong> Similar to above - <code>decltype(auto)</code> deduces id-expressions only by type.
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
int x;
[=] {
    decltype(auto) v = (x);
}
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>const int&amp;</code>
      <br>
      <strong>Explanation:</strong> Captures by value are <code>const</code>, and we are evaluting a non-id expression.
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
int x;
[=] mutable {
    decltype(auto) v = (x);
}
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> <code>int&amp;</code>
      <br>
      <strong>Explanation:</strong> Unless, of course, we make the lambda <code>mutable</code>. Then the captures are non-<code>const</code>.
    </div>
  </details>
</div>
<div class="auto-quiz-block">
  <pre><code>
int x;
int& y = x;
[=] () {
    decltype(auto) v = y;
}();
</code></pre>

  <details>
    <summary>Answer</summary>
    <div>
      <strong>Type:</strong> Fails to compile.
      <br>
      <strong>Explanation:</strong> <code>y</code> is an <code>int&amp;</code> outside the lambda. But <em>inside</em> the lambda, it is a <code>const</code> int&amp;. This fails because we are discarding the captured <code>y</code>&rsquo;s <code>const</code> qualifier.
    </div>
  </details>
</div>
<h1 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h1>
<p>You can check any of these by using this <a href="https://godbolt.org/z/f83vKh8j8">GodBolt link</a>. Shoutout to this <a href="https://stackoverflow.com/questions/81870/is-it-possible-to-print-the-name-of-a-variables-type-in-standard-c/56766138#56766138">Stack Overflow thread</a> which provided the code snippit to print human readable names for a variable.</p>
<p>Do you have any interesting examples to share? Reach out at <a href="mailto:sam@volatileint.dev">sam@volatileint.dev</a> and let me know!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://www.volatileint.dev/tags/c&#43;&#43;/">C&#43;&#43;</a></li>
      <li><a href="https://www.volatileint.dev/tags/type/">Type</a></li>
      <li><a href="https://www.volatileint.dev/tags/deduction/">Deduction</a></li>
      <li><a href="https://www.volatileint.dev/tags/auto/">Auto</a></li>
      <li><a href="https://www.volatileint.dev/tags/quiz/">Quiz</a></li>
    </ul>

<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Can you survive the C&#43;&#43; Auto Type Gauntlet? on x"
            href="https://x.com/intent/tweet/?text=Can%20you%20survive%20the%20C%2b%2b%20Auto%20Type%20Gauntlet%3f&amp;url=https%3a%2f%2fwww.volatileint.dev%2fposts%2fauto-type-deduction-gauntlet%2f&amp;hashtags=C%2b%2b%2ctype%2cdeduction%2cauto%2cquiz">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Can you survive the C&#43;&#43; Auto Type Gauntlet? on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwww.volatileint.dev%2fposts%2fauto-type-deduction-gauntlet%2f&amp;title=Can%20you%20survive%20the%20C%2b%2b%20Auto%20Type%20Gauntlet%3f&amp;summary=Can%20you%20survive%20the%20C%2b%2b%20Auto%20Type%20Gauntlet%3f&amp;source=https%3a%2f%2fwww.volatileint.dev%2fposts%2fauto-type-deduction-gauntlet%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Can you survive the C&#43;&#43; Auto Type Gauntlet? on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fwww.volatileint.dev%2fposts%2fauto-type-deduction-gauntlet%2f&title=Can%20you%20survive%20the%20C%2b%2b%20Auto%20Type%20Gauntlet%3f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Can you survive the C&#43;&#43; Auto Type Gauntlet? on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.volatileint.dev%2fposts%2fauto-type-deduction-gauntlet%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Can you survive the C&#43;&#43; Auto Type Gauntlet? on whatsapp"
            href="https://api.whatsapp.com/send?text=Can%20you%20survive%20the%20C%2b%2b%20Auto%20Type%20Gauntlet%3f%20-%20https%3a%2f%2fwww.volatileint.dev%2fposts%2fauto-type-deduction-gauntlet%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Can you survive the C&#43;&#43; Auto Type Gauntlet? on telegram"
            href="https://telegram.me/share/url?text=Can%20you%20survive%20the%20C%2b%2b%20Auto%20Type%20Gauntlet%3f&amp;url=https%3a%2f%2fwww.volatileint.dev%2fposts%2fauto-type-deduction-gauntlet%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Can you survive the C&#43;&#43; Auto Type Gauntlet? on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Can%20you%20survive%20the%20C%2b%2b%20Auto%20Type%20Gauntlet%3f&u=https%3a%2f%2fwww.volatileint.dev%2fposts%2fauto-type-deduction-gauntlet%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://www.volatileint.dev/">Volatile Int</a></span> · 
    <span>
        <a href="https://www.volatileint.dev/index.xml">Subscribe via RSS</a>
    </span> · 
    <span>
        <a href="https://buttondown.com/volatileint">Subscribe via Newsletter</a>
    </span> · 
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
mermaid.initialize({ startOnLoad: true });
</script>
</body>
</html>
