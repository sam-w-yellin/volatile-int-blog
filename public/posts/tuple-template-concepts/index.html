<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">
<link rel="stylesheet" href="https://www.volatileint.dev/css/custom.css">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Applying Template Concepts to Tuples in C&#43;&#43;  | Volatile Int</title>
<meta name="keywords" content="crunch, C&#43;&#43;, template, tuple, concept">
<meta name="description" content="This article is going to walk through a few different ways to constrain the types within a tuple used as a template parameter. In C&#43;&#43;, tuples are a collection of values of different types. You can access different elements at compile time via the get method. The very commonly used std::pair is a two-element tuple-like type.
While developing Crunch , I had quite a few use cases for applying template concepts to tuples and found some good - and not so good - ways to do it. Hopefully by the end of this article, you feel comfortable writing template concepts targeting std::tuple parameters!">
<meta name="author" content="">
<link rel="canonical" href="https://www.volatileint.dev/posts/tuple-template-concepts/">
<link crossorigin="anonymous" href="https://www.volatileint.dev/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css" integrity="sha256-NDzEgLn/yPBMy&#43;XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://www.volatileint.dev/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.volatileint.dev/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.volatileint.dev/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://www.volatileint.dev/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.volatileint.dev/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://www.volatileint.dev/posts/tuple-template-concepts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-N81PSXWFLZ"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-N81PSXWFLZ');
        }
      </script><meta property="og:url" content="https://www.volatileint.dev/posts/tuple-template-concepts/">
  <meta property="og:site_name" content="Volatile Int">
  <meta property="og:title" content="Applying Template Concepts to Tuples in C&#43;&#43; ">
  <meta property="og:description" content="This article is going to walk through a few different ways to constrain the types within a tuple used as a template parameter. In C&#43;&#43;, tuples are a collection of values of different types. You can access different elements at compile time via the get method. The very commonly used std::pair is a two-element tuple-like type.
While developing Crunch , I had quite a few use cases for applying template concepts to tuples and found some good - and not so good - ways to do it. Hopefully by the end of this article, you feel comfortable writing template concepts targeting std::tuple parameters!">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-12-23T00:00:00-08:00">
    <meta property="article:modified_time" content="2025-12-23T00:00:00-08:00">
    <meta property="article:tag" content="Crunch">
    <meta property="article:tag" content="C&#43;&#43;">
    <meta property="article:tag" content="Template">
    <meta property="article:tag" content="Tuple">
    <meta property="article:tag" content="Concept">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Applying Template Concepts to Tuples in C&#43;&#43; ">
<meta name="twitter:description" content="This article is going to walk through a few different ways to constrain the types within a tuple used as a template parameter. In C&#43;&#43;, tuples are a collection of values of different types. You can access different elements at compile time via the get method. The very commonly used std::pair is a two-element tuple-like type.
While developing Crunch , I had quite a few use cases for applying template concepts to tuples and found some good - and not so good - ways to do it. Hopefully by the end of this article, you feel comfortable writing template concepts targeting std::tuple parameters!">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://www.volatileint.dev/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Applying Template Concepts to Tuples in C++ ",
      "item": "https://www.volatileint.dev/posts/tuple-template-concepts/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Applying Template Concepts to Tuples in C++ ",
  "name": "Applying Template Concepts to Tuples in C\u002b\u002b ",
  "description": "This article is going to walk through a few different ways to constrain the types within a tuple used as a template parameter. In C++, tuples are a collection of values of different types. You can access different elements at compile time via the get method. The very commonly used std::pair is a two-element tuple-like type.\nWhile developing Crunch , I had quite a few use cases for applying template concepts to tuples and found some good - and not so good - ways to do it. Hopefully by the end of this article, you feel comfortable writing template concepts targeting std::tuple parameters!\n",
  "keywords": [
    "crunch", "C++", "template", "tuple", "concept"
  ],
  "articleBody": "This article is going to walk through a few different ways to constrain the types within a tuple used as a template parameter. In C++, tuples are a collection of values of different types. You can access different elements at compile time via the get method. The very commonly used std::pair is a two-element tuple-like type.\nWhile developing Crunch , I had quite a few use cases for applying template concepts to tuples and found some good - and not so good - ways to do it. Hopefully by the end of this article, you feel comfortable writing template concepts targeting std::tuple parameters!\nFor folks who want an at-a-glance solution and are less interested in the motivation and details, I’ll quickly show what we’re going to build up to.\nWhen you need to inspect types or constexpr values of each element:\ntemplate \u003ctypename Tuple\u003e concept ElementsAreIntegral = []\u003cstd::size_t... Is\u003e(std::index_sequence\u003cIs...\u003e) { return (std::integral\u003c std::remove_cvref_t\u003cstd::tuple_element_t\u003cIs, Tuple\u003e\u003e \u003e \u0026\u0026 ...); }(std::make_index_sequence\u003cstd::tuple_size_v\u003cTuple\u003e\u003e{}); When you don’t need to inspect each element\ntemplate\u003ctypename Tuple\u003e concept ElementsSatisfyConcept = requires { std::apply( []\u003ctypename... Ts\u003e(Ts\u0026\u0026...) requires (std::remove_cvref_t\u003cYourConcept\u003cTs\u003e\u003e \u0026\u0026 ...) {}, std::declval\u003cTuple\u003e() ); }; Note: In practice, std::apply often produces noticeably worse diagnostics than index-sequence approaches, so you might opt for the first solution even if you don’t need to access elements.\nThe rest of this article will provide the context on why that works, and motivate how you could arrive there yourself from the ground up.\nSetting the Stage Take a template class which takes some tuple:\ntemplate \u003ctypename Tuple\u003e class Foo { Tuple my_tuple; }; Going forward, I will omit the constraint that actually forces Tuple to be a std::tuple because it is a bit orthogonal to the topic of applying concepts to tuple elements. A simple one might look something like this:\ntemplate \u003ctypename T\u003e concept TupleLike = requires { typename std::tuple_size\u003cT\u003e::type; } \u0026\u0026 requires(T t) { std::get\u003c0\u003e(t); }; Let’s say that we want each element in Tuple to satisfy std::integral or compilation should fail. Something ergonomically similar to this:\ntemplate \u003ctypename Tuple\u003e requires ElementsAreIntegral\u003cTuple\u003e class Foo { Tuple my_tuple; }; In this case, we don’t really care what the value or type of each individual element in the tuple is - we just care that the type satisfies some constraint. The intuitive high-level approach to accomplishing this is:\nSomehow “unpack” the tuple into each of its elements. Apply the std::integral concept to each Fail the concept if any do not satisfy std::integral. First, let’s look at a naive approach, and then we’ll clean it up.\nThe Manual Approach In our first approach, we’re going to tackle each of the above steps independently. I call this “manual” because it uses fewer language features and more boilerplate as compared to the next solutions we will look at. You should almost never write this in real code, but I want to demonstrate the mechanics with a minimal set of language features.\nFirst off, we know that we need a concept called ElementsAreIntegral.\ntemplate\u003ctypename Tuple\u003e concept ElementsAreIntegral = // ...something... Our goal is to have ElementsAreIntegral evaluate to true when the elements meet std::integral and false when they do not.\nFirst, we know that we ultimately are going to need to unpack this tuple and check the elements. So we know we need something that expands out all the tuple elements, applies the target concept, and returns false if any are not satisfied:\n// Note: this cannot be our final concept — it requires an index pack template \u003ctypename Tuple, std::size_t... Is\u003e concept ElementsAreIntegralWithSequenceIdx = (std::integral\u003cstd::tuple_element_t\u003cIs, Tuple\u003e\u003e \u0026\u0026 ...); Its possible the the tuple was declared with reference or CV-qualified parameters, and your concept probably takes an unqualified, non-reference value. So you’ll probably want to actually make sure we strip the reference \u0026 CV qualification from the tuple elements:\n// Note: this cannot be our final concept — it requires an index pack template \u003ctypename Tuple, std::size_t... Is\u003e concept ElementsAreIntegralWithSequenceIdx = (std::integral\u003cstd::remove_cvref_t\u003c std::tuple_element_t\u003cIs, Tuple\u003e\u003e \u003e \u0026\u0026 ...); This looks really close to what we want. We are assuming we somehow create a variadic template pack Is which represents the index of each element. Then, when unpacking, we use the index to get the tuple element then logically AND the result of each individual tuple element’s concept check.\nHow do we get Is? The STL contains a few utility functions that combine to do exactly what we need. First, we can use std::tuple_size_v to extract out the size of a the tuple, then we can pass the result as a template parameter to std::make_index_sequence to get the Is parameter pack. This snippet does what we need for a given Tuple typename:\nstd::make_index_sequence\u003cstd::tuple_size_v\u003cTuple\u003e\u003e; Now we have most of the logic in place. But we need to bridge the gap between the desired concept - which takes only the Tuple parameter - and this concept which takes in the tuple and a sequence of indices. Intuitively, it probably seems like this is the right sort of approach:\ntemplate \u003ctypename Tuple, std::size_t... Is\u003e concept ElementsAreIntegralImpl = (std::integral\u003cstd::remove_cvref_t\u003c std::tuple_element_t\u003cIs, Tuple\u003e\u003e \u003e \u0026\u0026 ...); template\u003ctypename Tuple\u003e concept ElementsAreIntegral = ElementsAreIntegralImpl\u003cTuple, std::make_index_sequence\u003cstd::tuple_size_v\u003cTuple\u003e\u003e\u003e; But there’s a problem here. Is is a parameter pack. std::make_index_sequence",
  "wordCount" : "2300",
  "inLanguage": "en",
  "datePublished": "2025-12-23T00:00:00-08:00",
  "dateModified": "2025-12-23T00:00:00-08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.volatileint.dev/posts/tuple-template-concepts/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Volatile Int",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.volatileint.dev/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.volatileint.dev/" accesskey="h" title="  (Alt + H)">
                <img src="https://www.volatileint.dev/images/top-logo-light.svg" alt="" aria-label="logo"
                    height="32"> </a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.volatileint.dev/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://www.volatileint.dev/newsletter/" title="Newsletter">
                    <span>Newsletter</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Applying Template Concepts to Tuples in C&#43;&#43; 
    </h1>
    <div class="post-meta"><span title='2025-12-23 00:00:00 -0800 PST'>December 23, 2025</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#setting-the-stage" aria-label="Setting the Stage">Setting the Stage</a></li>
                <li>
                    <a href="#the-manual-approach" aria-label="The Manual Approach">The Manual Approach</a></li>
                <li>
                    <a href="#variadic-lambda-approach" aria-label="Variadic Lambda Approach">Variadic Lambda Approach</a></li>
                <li>
                    <a href="#stdapply-approach" aria-label="std::apply Approach">std::apply Approach</a></li>
                <li>
                    <a href="#real-world-example" aria-label="Real-World Example">Real-World Example</a></li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>This article is going to walk through a few different ways to constrain the types within a tuple used as a template parameter. In C++, tuples are a collection of values of different types. You can access different elements at compile time via the <code>get</code> method. The very commonly used std::pair is a two-element tuple-like type.</p>
<p>While developing Crunch <!-- raw HTML omitted -->, I had quite a few use cases for applying template concepts to tuples and found some good - and not so good - ways to do it. Hopefully by the end of this article, you feel comfortable writing template concepts targeting <code>std::tuple</code> parameters!</p>
<p>For folks who want an at-a-glance solution and are less interested in the motivation and details, I&rsquo;ll quickly show what we&rsquo;re going to build up to.</p>
<p><em>When you need to inspect types or constexpr values of each element</em>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Tuple<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">concept</span> ElementsAreIntegral <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    []<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>size_t... Is<span style="color:#f92672">&gt;</span>(std<span style="color:#f92672">::</span>index_sequence<span style="color:#f92672">&lt;</span>Is...<span style="color:#f92672">&gt;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> (std<span style="color:#f92672">::</span>integral<span style="color:#f92672">&lt;</span>
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>remove_cvref_t<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>tuple_element_t<span style="color:#f92672">&lt;</span>Is, Tuple<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;&amp;</span> ...);
</span></span><span style="display:flex;"><span>    }(std<span style="color:#f92672">::</span>make_index_sequence<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>tuple_size_v<span style="color:#f92672">&lt;</span>Tuple<span style="color:#f92672">&gt;&gt;</span>{});
</span></span></code></pre></div><p><em>When you don&rsquo;t need to inspect each element</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Tuple<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">concept</span> ElementsSatisfyConcept <span style="color:#f92672">=</span> <span style="color:#66d9ef">requires</span> {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>apply(
</span></span><span style="display:flex;"><span>        []<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span>... Ts<span style="color:#f92672">&gt;</span>(Ts<span style="color:#f92672">&amp;&amp;</span>...)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">requires</span> (std<span style="color:#f92672">::</span>remove_cvref_t<span style="color:#f92672">&lt;</span>YourConcept<span style="color:#f92672">&lt;</span>Ts<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">&amp;&amp;</span> ...) {},
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>declval<span style="color:#f92672">&lt;</span>Tuple<span style="color:#f92672">&gt;</span>()
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Note: In practice, <code>std::apply</code> often produces noticeably worse diagnostics than index-sequence approaches, so you might opt for the first solution even if you don&rsquo;t need to access elements.</p>
<p>The rest of this article will provide the context on why that works, and motivate how you could arrive there yourself from the ground up.</p>
<h1 id="setting-the-stage">Setting the Stage<a hidden class="anchor" aria-hidden="true" href="#setting-the-stage">#</a></h1>
<p>Take a template class which takes some tuple:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Tuple<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    Tuple my_tuple;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Going forward, I will omit the constraint that actually forces <code>Tuple</code> to be a <code>std::tuple</code> because it is a bit orthogonal to the topic of applying concepts to tuple <em>elements</em>. A simple one might look something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">concept</span> TupleLike <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">requires</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">typename</span> std<span style="color:#f92672">::</span>tuple_size<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>type;
</span></span><span style="display:flex;"><span>    } <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">requires</span>(T t) {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>get<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span><span style="color:#f92672">&gt;</span>(t);
</span></span><span style="display:flex;"><span>    };
</span></span></code></pre></div><p>Let&rsquo;s say that we want each element in <code>Tuple</code> to satisfy <code>std::integral</code> or compilation should fail. Something ergonomically similar to this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Tuple<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">requires</span> ElementsAreIntegral<span style="color:#f92672">&lt;</span>Tuple<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Foo</span> {
</span></span><span style="display:flex;"><span>    Tuple my_tuple;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>In this case, we don&rsquo;t really care what the value or type of each individual element in the tuple is - we just care that the type satisfies some constraint. The intuitive high-level approach to accomplishing this is:</p>
<ol>
<li>Somehow &ldquo;unpack&rdquo; the tuple into each of its elements.</li>
<li>Apply the <code>std::integral</code> concept to each</li>
<li>Fail the concept if any do not satisfy <code>std::integral</code>.</li>
</ol>
<p>First, let&rsquo;s look at a naive approach, and then we&rsquo;ll clean it up.</p>
<h1 id="the-manual-approach">The Manual Approach<a hidden class="anchor" aria-hidden="true" href="#the-manual-approach">#</a></h1>
<p>In our first approach, we&rsquo;re going to tackle each of the above steps independently. I call this &ldquo;manual&rdquo; because it uses fewer language features and more boilerplate as compared to the next solutions we will look at. You should almost never write this in real code, but I want to demonstrate the mechanics with a minimal set of language features.</p>
<p>First off, we know that we need a <code>concept</code> called <code>ElementsAreIntegral</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Tuple<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">concept</span> ElementsAreIntegral <span style="color:#f92672">=</span> <span style="color:#75715e">// ...something...
</span></span></span></code></pre></div><p>Our goal is to have <code>ElementsAreIntegral</code> evaluate to <code>true</code> when the elements meet <code>std::integral</code> and <code>false</code> when they do not.</p>
<p>First, we know that we ultimately are going to need to unpack this tuple and check the elements.  So we know we need something that expands out all the tuple elements, applies the target concept, and returns false if any are not satisfied:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// Note: this cannot be our final concept — it requires an index pack
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Tuple, std<span style="color:#f92672">::</span>size_t... Is<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">concept</span> ElementsAreIntegralWithSequenceIdx <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    (std<span style="color:#f92672">::</span>integral<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>tuple_element_t<span style="color:#f92672">&lt;</span>Is, Tuple<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">&amp;&amp;</span> ...);
</span></span></code></pre></div><p>Its possible the the tuple was declared with reference or CV-qualified parameters, and your concept probably takes an unqualified, non-reference value. So you&rsquo;ll probably want to actually make sure we strip the reference &amp; CV qualification from the tuple elements:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// Note: this cannot be our final concept — it requires an index pack
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Tuple, std<span style="color:#f92672">::</span>size_t... Is<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">concept</span> ElementsAreIntegralWithSequenceIdx <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    (std<span style="color:#f92672">::</span>integral<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>remove_cvref_t<span style="color:#f92672">&lt;</span>
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>tuple_element_t<span style="color:#f92672">&lt;</span>Is, Tuple<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;&amp;</span> ...);
</span></span></code></pre></div><p>This looks really close to what we want. We are assuming we somehow create a variadic template pack <code>Is</code> which represents the index of each element. Then, when unpacking, we use the index to get the tuple element then logically <code>AND</code> the result of each individual tuple element&rsquo;s concept check.</p>
<p>How do we get <code>Is</code>? The <code>STL</code> contains a few utility functions that combine to do  exactly what we need. First, we can use <code>std::tuple_size_v</code> to extract out the size of a the tuple, then we can pass the result as a template parameter to <code>std::make_index_sequence</code> to get the <code>Is</code> parameter pack.  This snippet does what we need for a given <code>Tuple</code> typename:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>make_index_sequence<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>tuple_size_v<span style="color:#f92672">&lt;</span>Tuple<span style="color:#f92672">&gt;&gt;</span>;
</span></span></code></pre></div><p>Now we have most of the logic in place. But we need to bridge the gap between the desired concept - which takes only the <code>Tuple</code> parameter - and this concept which takes in the tuple and a sequence of indices. Intuitively, it probably seems like this is the right sort of approach:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Tuple, std<span style="color:#f92672">::</span>size_t... Is<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">concept</span> ElementsAreIntegralImpl <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>   (std<span style="color:#f92672">::</span>integral<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>remove_cvref_t<span style="color:#f92672">&lt;</span>
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>tuple_element_t<span style="color:#f92672">&lt;</span>Is, Tuple<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;&amp;</span> ...);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Tuple<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">concept</span> ElementsAreIntegral <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    ElementsAreIntegralImpl<span style="color:#f92672">&lt;</span>Tuple, std<span style="color:#f92672">::</span>make_index_sequence<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>tuple_size_v<span style="color:#f92672">&lt;</span>Tuple<span style="color:#f92672">&gt;&gt;&gt;</span>;
</span></span></code></pre></div><p>But there&rsquo;s a problem here. <code>Is</code> is a <em>parameter pack</em>. <code>std::make_index_sequence&lt;std::tuple_size_v&lt;Tuple&gt;&gt;</code> returns a <em>type</em> which has the parameter pack we want <em>inside</em>. Something like <code>std::index_sequence&lt;0, 1, 2, ..., N&gt;</code>. In order to get at that set of indices inside the sequence, we need to figure out a way to bind to that sequence. We can do this with a <em>partial template specialization</em>.</p>
<p>What we need is a template that is specialized on the <code>std::index_sequence</code> parameter pack. Something like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>size_t...Is<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">sequence_extractor</span><span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>index_sequence<span style="color:#f92672">&lt;</span>Is...<span style="color:#f92672">&gt;&gt;</span> {};
</span></span></code></pre></div><p>Now, we have a mechanism to bind the results of <code>std::make_index_sequence</code> to a template parameter pack. We need to utilize that mechanism, while still returning either a boolean value to the top-level <code>ElementsAreIntegral</code> concept. We can is utilize a struct that extracts out the <code>std::index_sequence</code> as a parameter pack, and have that struct extend <code>std::bool_constant</code>, where the <code>value</code> of that boolean constant is predicated on the result of <code>ElementsAreIntegralImpl</code>. That&rsquo;s quite a mouthful, let&rsquo;s write it out step by step.</p>
<p>First, we define our top-level concept predicated on the <code>::value</code> of a struct. We&rsquo;ll call that struct <code>SequenceHelper</code>. It is templated on the Tuple and the result of <code>std::make_index_sequence</code> - both parameters are required because we need to forward them onto the <code>ElementsAreIntegralImpl</code> concept.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Tuple<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">concept</span> ElementsAreIntegral <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    SequenceHelper<span style="color:#f92672">&lt;</span>
</span></span><span style="display:flex;"><span>        Tuple, 
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>make_index_sequence<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>tuple_size_v<span style="color:#f92672">&lt;</span>Tuple<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&gt;::</span>value
</span></span></code></pre></div><p>Now, we need to actually write our <code>SequenceHelper</code>. Remember, this thing&rsquo;s job is to bind a template parameter to the <code>std::index_sequence</code>&rsquo;s parameter pack, and forward it to the <code>ElementsAreIntegralImpl</code> which actually checks if each element fulfills <code>std::integral</code>. The result of that concept should be stored in the struct&rsquo;s <code>::value</code> result. We can have the struct inherit from <code>bool_constant</code> so that it has a <code>::value</code> static data member. Something like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#75715e">// base
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Tuple, <span style="color:#66d9ef">typename</span> IndexSeq<span style="color:#f92672">&gt;</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SequenceHelper</span> <span style="color:#f92672">:</span> std<span style="color:#f92672">::</span>false_type {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// partial specialization
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Tuple, std<span style="color:#f92672">::</span>size_t...Is<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SequenceHelper</span><span style="color:#f92672">&lt;</span>Tuple, std<span style="color:#f92672">::</span>index_sequence<span style="color:#f92672">&lt;</span>Is...<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">:</span> std<span style="color:#f92672">::</span>bool_constant<span style="color:#f92672">&lt;</span>ElementsAreIntegralImpl<span style="color:#f92672">&lt;</span>Tuple, Is...<span style="color:#f92672">&gt;&gt;</span> {};
</span></span></code></pre></div><p>See how we were able to <em>extract</em> the parameter pack from the <code>std::index_sequence</code> and pass it to <code>ElementsAreIntegralImpl</code>? We now can pull it all together for our final, working implementation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Tuple, std<span style="color:#f92672">::</span>size_t... Is<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">concept</span> ElementsAreIntegralImpl <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    (std<span style="color:#f92672">::</span>integral<span style="color:#f92672">&lt;</span>
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>remove_cvref_t<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>tuple_element_t<span style="color:#f92672">&lt;</span>Is, Tuple<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;&amp;</span> ...);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// base
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Tuple, <span style="color:#66d9ef">typename</span> IndexSeq<span style="color:#f92672">&gt;</span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SequenceHelper</span> <span style="color:#f92672">:</span> std<span style="color:#f92672">::</span>false_type {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// partial specialization
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Tuple, std<span style="color:#f92672">::</span>size_t...Is<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SequenceHelper</span><span style="color:#f92672">&lt;</span>Tuple, std<span style="color:#f92672">::</span>index_sequence<span style="color:#f92672">&lt;</span>Is...<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">:</span> std<span style="color:#f92672">::</span>bool_constant<span style="color:#f92672">&lt;</span>ElementsAreIntegralImpl<span style="color:#f92672">&lt;</span>Tuple, Is...<span style="color:#f92672">&gt;&gt;</span> {};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Tuple<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">concept</span> ElementsAreIntegral <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    SequenceHelper<span style="color:#f92672">&lt;</span>
</span></span><span style="display:flex;"><span>        Tuple, 
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>make_index_sequence<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>tuple_size_v<span style="color:#f92672">&lt;</span>Tuple<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&gt;::</span>value;
</span></span></code></pre></div><p>This example can be seen in action at this <a href="https://godbolt.org/z/6fW61fqbs">Godbolt link</a>.</p>
<h1 id="variadic-lambda-approach">Variadic Lambda Approach<a hidden class="anchor" aria-hidden="true" href="#variadic-lambda-approach">#</a></h1>
<p>Along with template concepts, C++20 introduced <em>generic template lambda</em> functions. These play in super interesting ways with template metaprogramming, and are very useful in simplifying the (in my view, very messy and hard to read) code in the &ldquo;manual&rdquo; approach. Here&rsquo;s the basic idea: instead of the &ldquo;helper&rdquo; structs for retrieving the parameter pack from inside the <code>std::index_sequence</code> and containing the result of the concept applied to each parameter, a template lambda can accept the sequence as a parameter. Then we can collapse both the &ldquo;implementation&rdquo; concept and the pack extraction into the top-level concept.</p>
<p>So, we want a concept that calls a templated lambda function which:</p>
<ol>
<li>Takes a <code>std::index_sequence</code> as an input parameter</li>
<li>Is templated on that sequence&rsquo;s parameter pack</li>
<li>Calls <code>std::integral</code> on each element in the pack</li>
</ol>
<p>If the result evaluates to <code>false</code> - meaning any of the elements is not integral, the concept evaluates to false.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Tuple<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">concept</span> ElementsAreIntegral <span style="color:#f92672">=</span> [] <span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>size_t... Is<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    (std<span style="color:#f92672">::</span>index_sequence<span style="color:#f92672">&lt;</span>Is...<span style="color:#f92672">&gt;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> (std<span style="color:#f92672">::</span>integral<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>remove_cvref_t<span style="color:#f92672">&lt;</span>
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>tuple_element_t<span style="color:#f92672">&lt;</span>Is, Tuple<span style="color:#f92672">&gt;&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;&amp;</span> ...);
</span></span><span style="display:flex;"><span>    }(std<span style="color:#f92672">::</span>make_index_sequence<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>tuple_size_v<span style="color:#f92672">&lt;</span>Tuple<span style="color:#f92672">&gt;&gt;</span>{});
</span></span></code></pre></div><p>And that&rsquo;s it. All the sequence-extraction is now handled by our templated lambda, so all the proxy types go away. Feel free to play around with the <a href="https://godbolt.org/z/YTzjsxM81">Godbolt example</a>.</p>
<h1 id="stdapply-approach">std::apply Approach<a hidden class="anchor" aria-hidden="true" href="#stdapply-approach">#</a></h1>
<p>You may have realized something about these previous examples - we don&rsquo;t <em>really</em> care what the type or value of any of the tuple elements is. All we really care about is if the element fulfills some concept. So, do we really need to actually create a <code>std::index_sequence</code> that can access each element individually? If you don&rsquo;t need to actually work with the type of each element, we can get even simpler than our previous example. When we don&rsquo;t really care about the elements we can take advantage of <code>std::apply</code> and variadic template lambdas together.</p>
<p>The intuition here is to utilize the same strategy of binding the tuple elements as a parameter pack to a lambda. Our goal is to create a lambda which is only well-formed if every element meets our desired concept, and then call it on the tuple inside a <code>requires</code> statement. This will fail if any element does not pass - without ever extracting an element explicitly. We&rsquo;ll start with a variadic, templated lambda. Remember - the code in a <code>concept</code>&rsquo;s <code>requires</code> statement is not actually evaluated. All that matters is it is <em>well formed</em>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>[]<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span>... Ts<span style="color:#f92672">&gt;</span>(Ts<span style="color:#f92672">&amp;&amp;</span>...) {}
</span></span></code></pre></div><p>We are going to bind the tuple elements as the parameter pack. We want this lambda&rsquo;s template to require each element fulfills <code>std::integral</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>[]<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span>... Ts<span style="color:#f92672">&gt;</span>(Ts<span style="color:#f92672">&amp;&amp;</span>...) <span style="color:#66d9ef">requires</span>
</span></span><span style="display:flex;"><span>    (std<span style="color:#f92672">::</span>integral<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>remove_cvref_t<span style="color:#f92672">&lt;</span>Ts<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">&amp;&amp;</span> ...) {}
</span></span></code></pre></div><p>We now want to unpack each tuple element into a parameter pack, and call this lambda on those elements. Luckily, this is <em>exactly</em> what <code>std::apply</code> does.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>std<span style="color:#f92672">::</span>apply(
</span></span><span style="display:flex;"><span>  []<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span>... Ts<span style="color:#f92672">&gt;</span>(Ts<span style="color:#f92672">&amp;&amp;</span>...) <span style="color:#66d9ef">requires</span>
</span></span><span style="display:flex;"><span>    (std<span style="color:#f92672">::</span>integral<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>remove_cvref_t<span style="color:#f92672">&lt;</span>Ts<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">&amp;&amp;</span> ...) {},
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ...something...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>);
</span></span></code></pre></div><p>The &ldquo;something&rdquo; we want is an instance of the tuple. Bringing it together as a concept we get:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Tuple<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">concept</span> ElementsAreIntegral <span style="color:#f92672">=</span> <span style="color:#66d9ef">requires</span> {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>apply(
</span></span><span style="display:flex;"><span>        []<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span>... Ts<span style="color:#f92672">&gt;</span>(Ts<span style="color:#f92672">&amp;&amp;</span>...) <span style="color:#66d9ef">requires</span>
</span></span><span style="display:flex;"><span>            (std<span style="color:#f92672">::</span>integral<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>remove_cvref_t<span style="color:#f92672">&lt;</span>Ts<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">&amp;&amp;</span> ...) {},
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>declval<span style="color:#f92672">&lt;</span>Tuple<span style="color:#f92672">&gt;</span>()
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Note: The <code>std::declval</code> call is used to instantiate a concrete Tuple parameter in a concept&rsquo;s <code>requires</code> clause.</p>
<p>This concept&rsquo;s <code>requires</code> clause is only well formed if the constrained lambda is a viable overload, which is only the case if each element in the parameter pack satisfies <code>std::integral</code>.</p>
<p>The <a href="https://godbolt.org/z/E1j9e4PE4">Godbolt as proof</a>. It&rsquo;s worth calling out that the error message through this approach is slightly more cryptic than in the others. We do eventually see the message about the failed concept, but it is preceded by lots of failures around <code>std::apply</code> as opposed to the extremely clear errors from the prior examples.</p>
<h1 id="real-world-example">Real-World Example<a hidden class="anchor" aria-hidden="true" href="#real-world-example">#</a></h1>
<p><code>Crunch</code>&rsquo;s <code>CRUNCH_MESSAGE_FIELDS</code> macro creates a <code>constexpr</code> <code>get_fields</code> function for easy iteration over all the fields in a message. It returns a tuple where each element is <code>crunch::field::Field</code>. I needed to apply two different template concepts to the set of elements in the tuple:</p>
<ol>
<li>Each field needed to satisfy the <code>ValidField</code> concept, which essentially ensures that the field is one of the Crunch field types (Scalar, Array, Map, Submessage).</li>
<li>The field&rsquo;s <code>FieldId</code> needs to be unique among all the fields in the message.</li>
</ol>
<p>To accomplish this, I utilized both the lambda-based approaches. The <a href="https://github.com/sam-w-yellin/crunch/blob/24f25f48600b88ea0039ae87b74a35fcda471b1f/include/crunch/messages/crunch_messages.hpp#L66">first case</a> was a great candidate for the <code>std::apply</code> approach - the specifics of each type was not important, just that it satisfies a particular concept.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Tuple<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">concept</span> tuple_members_are_valid_fields <span style="color:#f92672">=</span> <span style="color:#66d9ef">requires</span> {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>apply([]<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span>... Ts<span style="color:#f92672">&gt;</span>(Ts<span style="color:#f92672">&amp;&amp;</span>...)
</span></span><span style="display:flex;"><span>                   <span style="color:#66d9ef">requires</span>(ValidField<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>remove_cvref_t<span style="color:#f92672">&lt;</span>Ts<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">&amp;&amp;</span> ...)
</span></span><span style="display:flex;"><span>               {},
</span></span><span style="display:flex;"><span>               std<span style="color:#f92672">::</span>declval<span style="color:#f92672">&lt;</span>Tuple<span style="color:#f92672">&gt;</span>());
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>In the <a href="https://github.com/sam-w-yellin/crunch/blob/24f25f48600b88ea0039ae87b74a35fcda471b1f/include/crunch/messages/crunch_messages.hpp#L86">second case</a> we actually needed to inspect a value inside of each tuple element - the <code>FieldId</code> - so I used the <code>std::make_index_sequence</code> approach.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Tuple<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">concept</span> has_unique_field_ids <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    []<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>size_t... Is<span style="color:#f92672">&gt;</span>(std<span style="color:#f92672">::</span>index_sequence<span style="color:#f92672">&lt;</span>Is...<span style="color:#f92672">&gt;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">!</span>has_duplicates<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>remove_cvref_t<span style="color:#f92672">&lt;</span>
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>tuple_element_t<span style="color:#f92672">&lt;</span>Is, Tuple<span style="color:#f92672">&gt;&gt;::</span>field_id...<span style="color:#f92672">&gt;::</span>value;
</span></span><span style="display:flex;"><span>    }(std<span style="color:#f92672">::</span>make_index_sequence<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>tuple_size_v<span style="color:#f92672">&lt;</span>Tuple<span style="color:#f92672">&gt;&gt;</span>{});
</span></span></code></pre></div><p>I&rsquo;ll briefly touch on the implementation of <code>has_duplicates</code> because it&rsquo;s rather interesting, although not strictly related to the rest of this deep dive. It&rsquo;s implemented like this (only the partial specialization is shown):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span>FieldId Head, FieldId... Tail<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">has_duplicates</span><span style="color:#f92672">&lt;</span>Head, Tail...<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">bool</span> value <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        ((Head <span style="color:#f92672">==</span> Tail) <span style="color:#f92672">||</span> ...) <span style="color:#f92672">||</span> has_duplicates<span style="color:#f92672">&lt;</span>Tail...<span style="color:#f92672">&gt;::</span>value;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>This has the really neat behavior of expanding out an equality check between all elements. First, we expand out comparing the <code>Head</code> element against each other element in the tuple. Then, when we pass in <code>Tail...</code> recursively to <code>has_duplicates</code>, the first element in <code>Tail</code> becomes the next head, and the comparisons continue. At the end, we have checked each element against each other. A quick walkthrough with a concrete set of <code>FieldId</code>s <code>{1, 2, 3}</code>:</p>
<ol>
<li>Head == 1, Tail == {2, 3}: 1 == 2 || 1 == 3. Then, OR with the result of call <code>has_duplicates&lt;{2, 3}&gt;</code></li>
<li>Head == 2, Tail == {3}: 2 == 3.</li>
<li>Combine: 1 == 2 || 1 == 3 || 2 == 3</li>
</ol>
<h1 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h1>
<p>Template metaprogramming can be hard to wrap your head around. Moreso than other C++ programming tasks, it can feel like the language is &ldquo;getting in the way&rdquo;. But with enough experience you&rsquo;ll start to be able to break down your desired outcome into achievable steps and compose concepts like the ones we saw today. Hopefully some of these patterns are useful in your own code.</p>
<p>If you’d like to discuss this pattern or how it might apply to your system, feel free to reach out: <a href="mailto:sam@volatileint.dev">sam@volatileint.dev</a></p>
<p>If you found this article valuable, consider subscribing to the <a href="https://volatileint.dev/newsletter">newsletter</a> to hear about new posts!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://www.volatileint.dev/tags/crunch/">Crunch</a></li>
      <li><a href="https://www.volatileint.dev/tags/c&#43;&#43;/">C&#43;&#43;</a></li>
      <li><a href="https://www.volatileint.dev/tags/template/">Template</a></li>
      <li><a href="https://www.volatileint.dev/tags/tuple/">Tuple</a></li>
      <li><a href="https://www.volatileint.dev/tags/concept/">Concept</a></li>
    </ul>

<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Applying Template Concepts to Tuples in C&#43;&#43;  on x"
            href="https://x.com/intent/tweet/?text=Applying%20Template%20Concepts%20to%20Tuples%20in%20C%2b%2b%20&amp;url=https%3a%2f%2fwww.volatileint.dev%2fposts%2ftuple-template-concepts%2f&amp;hashtags=crunch%2cC%2b%2b%2ctemplate%2ctuple%2cconcept">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Applying Template Concepts to Tuples in C&#43;&#43;  on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fwww.volatileint.dev%2fposts%2ftuple-template-concepts%2f&amp;title=Applying%20Template%20Concepts%20to%20Tuples%20in%20C%2b%2b%20&amp;summary=Applying%20Template%20Concepts%20to%20Tuples%20in%20C%2b%2b%20&amp;source=https%3a%2f%2fwww.volatileint.dev%2fposts%2ftuple-template-concepts%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Applying Template Concepts to Tuples in C&#43;&#43;  on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fwww.volatileint.dev%2fposts%2ftuple-template-concepts%2f&title=Applying%20Template%20Concepts%20to%20Tuples%20in%20C%2b%2b%20">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Applying Template Concepts to Tuples in C&#43;&#43;  on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.volatileint.dev%2fposts%2ftuple-template-concepts%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Applying Template Concepts to Tuples in C&#43;&#43;  on whatsapp"
            href="https://api.whatsapp.com/send?text=Applying%20Template%20Concepts%20to%20Tuples%20in%20C%2b%2b%20%20-%20https%3a%2f%2fwww.volatileint.dev%2fposts%2ftuple-template-concepts%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Applying Template Concepts to Tuples in C&#43;&#43;  on telegram"
            href="https://telegram.me/share/url?text=Applying%20Template%20Concepts%20to%20Tuples%20in%20C%2b%2b%20&amp;url=https%3a%2f%2fwww.volatileint.dev%2fposts%2ftuple-template-concepts%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Applying Template Concepts to Tuples in C&#43;&#43;  on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Applying%20Template%20Concepts%20to%20Tuples%20in%20C%2b%2b%20&u=https%3a%2f%2fwww.volatileint.dev%2fposts%2ftuple-template-concepts%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://www.volatileint.dev/">Volatile Int</a></span> · 
    <span>
        <a href="https://www.volatileint.dev/index.xml">Subscribe via RSS</a>
    </span> · 
    <span>
        <a href="https://buttondown.com/volatileint">Subscribe via Newsletter</a>
    </span> · 
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
mermaid.initialize({ startOnLoad: true });
</script>
</body>
</html>
