<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Volatile Int</title>
    <link>https://www.volatileint.dev/</link>
    <description>Recent content on Volatile Int</description>
    <generator>Hugo -- 0.152.2</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 05 Dec 2025 12:00:00 -0800</lastBuildDate>
    <atom:link href="https://www.volatileint.dev/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Can You Survive the C&#43;&#43; Auto Type Deduction Gauntlet?</title>
      <link>https://www.volatileint.dev/posts/auto-type-deduction-gauntlet/</link>
      <pubDate>Fri, 05 Dec 2025 12:00:00 -0800</pubDate>
      <guid>https://www.volatileint.dev/posts/auto-type-deduction-gauntlet/</guid>
      <description>&lt;p&gt;One of the most iconic C++ features is the language&amp;rsquo;s ability to deduce types with the &lt;code&gt;auto&lt;/code&gt; keyword. In this post, I&amp;rsquo;ll give a series of code snippits. Your job is to assess what will be deduced for &lt;code&gt;v&lt;/code&gt; in each case. Determine for each:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The deduced type&lt;/li&gt;
&lt;li&gt;If it is a value, an lvalue or rvalue reference, or a pointer&lt;/li&gt;
&lt;li&gt;Which CV qualifiers are applicable&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Some of these may not even compile, so &amp;ldquo;this won&amp;rsquo;t work&amp;rdquo; is a totally valid answer.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Implementing a Framework For Closed-Loop Controllers in Modern C&#43;&#43;</title>
      <link>https://www.volatileint.dev/posts/feedback-controller/</link>
      <pubDate>Wed, 26 Nov 2025 11:00:00 -0800</pubDate>
      <guid>https://www.volatileint.dev/posts/feedback-controller/</guid>
      <description>&lt;p&gt;In this post, we&amp;rsquo;re going to implement a generic interface for creating a wide variety of closed-loop control systems. We&amp;rsquo;ll end with a flexible template library capable of implementing whatever control algorithm you&amp;rsquo;d want, enforced separation of concerns, flexible configuration, consistent error handling, and support for logging. We will use modern C++ infrastructure such as template &lt;code&gt;concept&lt;/code&gt;s,  &lt;code&gt;std::expected&lt;/code&gt;, and lambda functions.&lt;/p&gt;
&lt;p&gt;Before we dive in, I want to acknowledge that the final code utilizes a good number of advanced C++ facilities for what may appear to be a relatively simple set of functionality. In the course of reading, you may balk at the complexity introduced for the sake of consistent abstraction. Hopefully the culmination of what we have built presented in the last section of the post sufficiently motivates the complexity tradeoff for projects with many controllers or which need to distribute the development responsibilities of the control laws and hardware interfaces across teams.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Dependency Inversion in C: A Technique for Extensible Embedded Software</title>
      <link>https://www.volatileint.dev/posts/dependency-inversion-c/</link>
      <pubDate>Sun, 16 Nov 2025 12:00:00 -0800</pubDate>
      <guid>https://www.volatileint.dev/posts/dependency-inversion-c/</guid>
      <description>&lt;p&gt;The core value proposition of software is flexibility - but in embedded systems, we often lose that advantage. Codebases become tightly coupled to a specific hardware revision, making even small platform changes expensive and risky. As hardware complexity grows linearly, software complexity grows exponentially. Costs rise. Schedules slip. Eventually organizations become resistant to improving their own products because the software architecture canâ€™t absorb change.&lt;/p&gt;
&lt;p&gt;This risk is avoidable. By intentionally separating the high-level business rules from low-level hardware details, we regain the flexibility software is supposed to provide. One of the most effective techniques for achieving this separation is &lt;a href=&#34;https://en.wikipedia.org/wiki/Dependency_inversion_principle&#34;&gt;dependency inversion&lt;/a&gt;. In short, lower-level components implement an interface defined at a higher level. Control still flows from high to low abstraction layers, but the &lt;em&gt;dependencies&lt;/em&gt; flow upward. High-level code is unaware of how the interface is concretely implemented. In an embedded context, this paradigm allows the software architecture to adapt quickly and cheaply to new hardware iterations without rewriting core logic.&lt;/p&gt;</description>
    </item>
    <item>
      <title>About Me</title>
      <link>https://www.volatileint.dev/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://www.volatileint.dev/about/</guid>
      <description>About Sam Yellin</description>
    </item>
    <item>
      <title>Newsletter</title>
      <link>https://www.volatileint.dev/newsletter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://www.volatileint.dev/newsletter/</guid>
      <description>Subscribe to the Newsletter</description>
    </item>
  </channel>
</rss>
